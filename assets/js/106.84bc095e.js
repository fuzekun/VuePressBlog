(window.webpackJsonp=window.webpackJsonp||[]).push([[106],{566:function(v,_,e){"use strict";e.r(_);var t=e(1),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("p",[_("img",{attrs:{src:"https://img-blog.csdnimg.cn/7f4f443b0a0747448034fbcd667302e8.png",alt:"在这里插入图片描述"}})]),v._v(" "),_("h3",{attrs:{id:"io-流简介"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#io-流简介"}},[v._v("#")]),v._v(" IO 流简介")]),v._v(" "),_("p",[v._v("IO 即 "),_("code",[v._v("Input/Output")]),v._v("，输入和输出。数据输入到计算机内存的过程即输入，反之输出到外部存储（比如数据库，文件，远程主机）的过程即输出。数据传输过程类似于水流，因此称为 IO 流。IO 流在 Java 中分为输入流和输出流，而根据数据的处理方式又分为字节流和字符流。")]),v._v(" "),_("p",[v._v("Java IO 流的 40 多个类都是从如下 4 个抽象类基类中派生出来的。")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("InputStream")]),v._v("/"),_("code",[v._v("Reader")]),v._v(": 所有的输入流的基类，前者是字节输入流，后者是字符输入流。")]),v._v(" "),_("li",[_("code",[v._v("OutputStream")]),v._v("/"),_("code",[v._v("Writer")]),v._v(": 所有输出流的基类，前者是字节输出流，后者是字符输出流。")])]),v._v(" "),_("h3",{attrs:{id:"字节流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字节流"}},[v._v("#")]),v._v(" 字节流")]),v._v(" "),_("p",[_("strong",[v._v("InputStream（字节输入流）")])]),v._v(" "),_("p",[_("code",[v._v("InputStream")]),v._v("用于从源头（通常是文件）读取数据（字节信息）到内存中，"),_("code",[v._v("java.io.InputStream")]),v._v("抽象类是所有字节输入流的父类。")]),v._v(" "),_("p",[_("code",[v._v("InputStream")]),v._v(" 常用方法 ：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("read()")]),v._v(" ：返回输入流中下一个字节的数据。返回的值介于 0 到 255 之间。如果未读取任何字节，则代码返回 "),_("code",[v._v("-1")]),v._v(" ，表示文件结束。")]),v._v(" "),_("li",[_("code",[v._v("read(byte b[ ])")]),v._v(" : 从输入流中读取一些字节存储到数组 "),_("code",[v._v("b")]),v._v(" 中。如果数组 "),_("code",[v._v("b")]),v._v(" 的长度为零，则不读取。如果没有可用字节读取，返回 "),_("code",[v._v("-1")]),v._v("。如果有可用字节读取，则最多读取的字节数最多等于 "),_("code",[v._v("b.length")]),v._v(" ， 返回读取的字节数。这个方法等价于 "),_("code",[v._v("read(b, 0, b.length)")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("read(byte b[], int off, int len)")]),v._v(" ：在"),_("code",[v._v("read(byte b[ ])")]),v._v(" 方法的基础上增加了 "),_("code",[v._v("off")]),v._v(" 参数（偏移量）和 "),_("code",[v._v("len")]),v._v(" 参数（要读取的最大字节数）。")]),v._v(" "),_("li",[_("code",[v._v("skip(long n)")]),v._v(" ：忽略输入流中的 n 个字节 ,返回实际忽略的字节数。")]),v._v(" "),_("li",[_("code",[v._v("available()")]),v._v(" ：返回输入流中可以读取的字节数。")]),v._v(" "),_("li",[_("code",[v._v("close()")]),v._v(" ：关闭输入流释放相关的系统资源。")])]),v._v(" "),_("p",[v._v("从 Java 9 开始，"),_("code",[v._v("InputStream")]),v._v(" 新增加了多个实用的方法：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("readAllBytes()")]),v._v(" ：读取输入流中的所有字节，返回字节数组。")]),v._v(" "),_("li",[_("code",[v._v("readNBytes(byte[] b, int off, int len)")]),v._v(" ：阻塞直到读取 "),_("code",[v._v("len")]),v._v(" 个字节。")]),v._v(" "),_("li",[_("code",[v._v("transferTo(OutputStream out)")]),v._v(" ： 将所有字节从一个输入流传递到一个输出流。")])]),v._v(" "),_("p",[_("code",[v._v("FileInputStream")]),v._v(" 是一个比较常用的字节输入流对象，可直接指定文件路径，可以直接读取单字节数据，也可以读取至字节数组中。")]),v._v(" "),_("p",[v._v("不过，一般我们是不会直接单独使用 "),_("code",[v._v("FileInputStream")]),v._v(" ，通常会配合 "),_("code",[v._v("BufferedInputStream")]),v._v("（字节缓冲输入流，后文会讲到）来使用。")]),v._v(" "),_("p",[v._v("另外，用于序列化和反序列化的类必须实现 "),_("code",[v._v("Serializable")]),v._v(" 接口，对象中如果有属性不想被序列化，使用 "),_("code",[v._v("transient")]),v._v(" 修饰。")]),v._v(" "),_("h4",{attrs:{id:"outputstream-字节输出流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#outputstream-字节输出流"}},[v._v("#")]),v._v(" OutputStream（字节输出流）")]),v._v(" "),_("p",[_("code",[v._v("OutputStream")]),v._v("用于将数据（字节信息）写入到目的地（通常是文件），"),_("code",[v._v("java.io.OutputStream")]),v._v("抽象类是所有字节输出流的父类。")]),v._v(" "),_("p",[_("code",[v._v("OutputStream")]),v._v(" 常用方法 ：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("write(int b)")]),v._v(" ：将特定字节写入输出流。")]),v._v(" "),_("li",[_("code",[v._v("write(byte b[ ])")]),v._v(" : 将数组"),_("code",[v._v("b")]),v._v(" 写入到输出流，等价于 "),_("code",[v._v("write(b, 0, b.length)")]),v._v(" 。")]),v._v(" "),_("li",[_("code",[v._v("write(byte[] b, int off, int len)")]),v._v(" : 在"),_("code",[v._v("write(byte b[ ])")]),v._v(" 方法的基础上增加了 "),_("code",[v._v("off")]),v._v(" 参数（偏移量）和 "),_("code",[v._v("len")]),v._v(" 参数（要读取的最大字节数）。")]),v._v(" "),_("li",[_("code",[v._v("flush()")]),v._v(" ：刷新此输出流并强制写出所有缓冲的输出字节。")]),v._v(" "),_("li",[_("code",[v._v("close()")]),v._v(" ：关闭输出流释放相关的系统资源。")])]),v._v(" "),_("p",[_("code",[v._v("FileOutputStream")]),v._v(" 是最常用的字节输出流对象，可直接指定文件路径，可以直接输出单字节数据，也可以输出指定的字节数组。")]),v._v(" "),_("h3",{attrs:{id:"字符流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符流"}},[v._v("#")]),v._v(" 字符流")]),v._v(" "),_("p",[v._v("不管是文件读写还是网络发送接收，信息的最小存储单元都是字节。 "),_("strong",[v._v("那为什么 I/O 流操作要分为字节流操作和字符流操作呢？")])]),v._v(" "),_("p",[v._v("个人认为主要有两点原因：")]),v._v(" "),_("ul",[_("li",[v._v("字符流是由 Java 虚拟机将字节转换得到的，这个过程还算是比较耗时。")]),v._v(" "),_("li",[v._v("如果我们不知道编码类型就很容易出现乱码问题。")])]),v._v(" "),_("p",[v._v("乱码问题这个很容易就可以复现，我们只需要将上面提到的 "),_("code",[v._v("FileInputStream")]),v._v(" 代码示例中的 "),_("code",[v._v("input.txt")]),v._v(" 文件内容改为中文即可，原代码不需要改动。")]),v._v(" "),_("p",[v._v("因此，I/O 流就干脆提供了一个直接操作字符的接口，方便我们平时对字符进行流操作。如果音频文件、图片等媒体文件用字节流比较好，如果涉及到字符的话使用字符流比较好。")]),v._v(" "),_("p",[v._v("字符流默认采用的是 "),_("code",[v._v("Unicode")]),v._v(" 编码，我们可以通过构造方法自定义编码。顺便分享一下之前遇到的笔试题：常用字符编码所占字节数？"),_("code",[v._v("utf8")]),v._v(" :英文占 1 字节，中文占 3 字节，"),_("code",[v._v("unicode")]),v._v("：任何字符都占 2 个字节，"),_("code",[v._v("gbk")]),v._v("：英文占 1 字节，中文占 2 字节.")]),v._v(" "),_("h4",{attrs:{id:"reader-字符输入流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#reader-字符输入流"}},[v._v("#")]),v._v(" Reader（字符输入流）")]),v._v(" "),_("p",[_("code",[v._v("Reader")]),v._v("用于从源头（通常是文件）读取数据（字符信息）到内存中，"),_("code",[v._v("java.io.Reader")]),v._v("抽象类是所有字符输入流的父类。")]),v._v(" "),_("p",[_("code",[v._v("Reader")]),v._v(" 用于读取文本， "),_("code",[v._v("InputStream")]),v._v(" 用于读取原始字节。")]),v._v(" "),_("p",[_("code",[v._v("Reader")]),v._v(" 常用方法 ：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("read()")]),v._v(" : 从输入流读取一个字符。")]),v._v(" "),_("li",[_("code",[v._v("read(char[] cbuf)")]),v._v(" : 从输入流中读取一些字符，并将它们存储到字符数组 "),_("code",[v._v("cbuf")]),v._v("中，等价于 "),_("code",[v._v("read(cbuf, 0, cbuf.length)")]),v._v(" 。")]),v._v(" "),_("li",[_("code",[v._v("read(char[] cbuf, int off, int len)")]),v._v(" ：在"),_("code",[v._v("read(char[] cbuf)")]),v._v(" 方法的基础上增加了 "),_("code",[v._v("off")]),v._v(" 参数（偏移量）和 "),_("code",[v._v("len")]),v._v(" 参数（要读取的最大字符数）。")]),v._v(" "),_("li",[_("code",[v._v("skip(long n)")]),v._v(" ：忽略输入流中的 n 个字符 ,返回实际忽略的字符数。")]),v._v(" "),_("li",[_("code",[v._v("close()")]),v._v(" : 关闭输入流并释放相关的系统资源。")])]),v._v(" "),_("p",[_("code",[v._v("InputStreamReader")]),v._v(" 是字节流转换为字符流的桥梁，其子类 "),_("code",[v._v("FileReader")]),v._v(" 是基于该基础上的封装，可以直接操作字符文件。")]),v._v(" "),_("h4",{attrs:{id:"writer-字符输出流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#writer-字符输出流"}},[v._v("#")]),v._v(" Writer（字符输出流）")]),v._v(" "),_("p",[_("code",[v._v("Writer")]),v._v("用于将数据（字符信息）写入到目的地（通常是文件），"),_("code",[v._v("java.io.Writer")]),v._v("抽象类是所有字节输出流的父类。")]),v._v(" "),_("p",[_("code",[v._v("Writer")]),v._v(" 常用方法 ：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("write(int c)")]),v._v(" : 写入单个字符。")]),v._v(" "),_("li",[_("code",[v._v("write(char[] cbuf)")]),v._v(" ：写入字符数组 "),_("code",[v._v("cbuf")]),v._v("，等价于"),_("code",[v._v("write(cbuf, 0, cbuf.length)")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("write(char[] cbuf, int off, int len)")]),v._v(" ：在"),_("code",[v._v("write(char[] cbuf)")]),v._v(" 方法的基础上增加了 "),_("code",[v._v("off")]),v._v(" 参数（偏移量）和 "),_("code",[v._v("len")]),v._v(" 参数（要读取的最大字符数）。")]),v._v(" "),_("li",[_("code",[v._v("write(String str)")]),v._v(" ：写入字符串，等价于 "),_("code",[v._v("write(str, 0, str.length())")]),v._v(" 。")]),v._v(" "),_("li",[_("code",[v._v("write(String str, int off, int len)")]),v._v(" ：在"),_("code",[v._v("write(String str)")]),v._v(" 方法的基础上增加了 "),_("code",[v._v("off")]),v._v(" 参数（偏移量）和 "),_("code",[v._v("len")]),v._v(" 参数（要读取的最大字符数）。")]),v._v(" "),_("li",[_("code",[v._v("append(CharSequence csq)")]),v._v(" ：将指定的字符序列附加到指定的 "),_("code",[v._v("Writer")]),v._v(" 对象并返回该 "),_("code",[v._v("Writer")]),v._v(" 对象。")]),v._v(" "),_("li",[_("code",[v._v("append(char c)")]),v._v(" ：将指定的字符附加到指定的 "),_("code",[v._v("Writer")]),v._v(" 对象并返回该 "),_("code",[v._v("Writer")]),v._v(" 对象。")]),v._v(" "),_("li",[_("code",[v._v("flush()")]),v._v(" ：刷新此输出流并强制写出所有缓冲的输出字符。")]),v._v(" "),_("li",[_("code",[v._v("close()")]),v._v(":关闭输出流释放相关的系统资源。")])]),v._v(" "),_("p",[_("code",[v._v("OutputStreamWriter")]),v._v(" 是字符流转换为字节流的桥梁，其子类 "),_("code",[v._v("FileWriter")]),v._v(" 是基于该基础上的封装，可以直接将字符写入到文件.")]),v._v(" "),_("h3",{attrs:{id:"字节缓冲流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字节缓冲流"}},[v._v("#")]),v._v(" 字节缓冲流")]),v._v(" "),_("p",[v._v("IO 操作是很消耗性能的，缓冲流将数据加载至缓冲区，一次性读取/写入多个字节，从而避免频繁的 IO 操作，提高流的传输效率。")]),v._v(" "),_("p",[v._v("字节缓冲流这里采用了装饰器模式来增强 "),_("code",[v._v("InputStream")]),v._v(" 和"),_("code",[v._v("OutputStream")]),v._v("子类对象的功能。")]),v._v(" "),_("p",[v._v("举个例子，我们可以通过 "),_("code",[v._v("BufferedInputStream")]),v._v("（字节缓冲输入流）来增强 "),_("code",[v._v("FileInputStream")]),v._v(" 的功能。")]),v._v(" "),_("p",[v._v("字节流和字节缓冲流的性能差别主要体现在我们使用两者的时候都是调用 "),_("code",[v._v("write(int b)")]),v._v(" 和"),_("code",[v._v("read()")]),v._v(" 这两个一次只读取一个字节的方法的时候。由于字节缓冲流内部有缓冲区（字节数组），因此，字节缓冲流会先将读取到的字节存放在缓存区，大幅减少 IO 次数，提高读取效率。")]),v._v(" "),_("h3",{attrs:{id:"bufferedinputstream-字节缓冲输入流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bufferedinputstream-字节缓冲输入流"}},[v._v("#")]),v._v(" BufferedInputStream（字节缓冲输入流）")]),v._v(" "),_("p",[_("code",[v._v("BufferedInputStream")]),v._v(" 从源头（通常是文件）读取数据（字节信息）到内存的过程中不会一个字节一个字节的读取，而是会先将读取到的字节存放在缓存区，并从内部缓冲区中单独读取字节。这样大幅减少了 IO 次数，提高了读取效率。")]),v._v(" "),_("p",[_("code",[v._v("BufferedInputStream")]),v._v(" 内部维护了一个缓冲区，这个缓冲区实际就是一个字节数组，通过阅读 "),_("code",[v._v("BufferedInputStream")]),v._v(" 源码即可得到这个结论。")]),v._v(" "),_("p",[v._v("缓冲区的大小默认为 "),_("strong",[v._v("8192")]),v._v(" 字节，当然了，你也可以通过 "),_("code",[v._v("BufferedInputStream(InputStream in, int size)")]),v._v(" 这个构造方法来指定缓冲区的大小。")]),v._v(" "),_("h3",{attrs:{id:"bufferedoutputstream-字节缓冲输出流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#bufferedoutputstream-字节缓冲输出流"}},[v._v("#")]),v._v(" BufferedOutputStream（字节缓冲输出流）")]),v._v(" "),_("p",[_("code",[v._v("BufferedOutputStream")]),v._v(" 将数据（字节信息）写入到目的地（通常是文件）的过程中不会一个字节一个字节的写入，而是会先将要写入的字节存放在缓存区，并从内部缓冲区中单独写入字节。这样大幅减少了 IO 次数，提高了读取效率。")]),v._v(" "),_("p",[v._v("类似于 "),_("code",[v._v("BufferedInputStream")]),v._v(" ，"),_("code",[v._v("BufferedOutputStream")]),v._v(" 内部也维护了一个缓冲区，并且，这个缓存区的大小也是 "),_("strong",[v._v("8192")]),v._v(" 字节。")]),v._v(" "),_("h3",{attrs:{id:"字符缓冲流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符缓冲流"}},[v._v("#")]),v._v(" 字符缓冲流")]),v._v(" "),_("p",[_("code",[v._v("BufferedReader")]),v._v(" （字符缓冲输入流）和 （字符缓冲输出流）类似于 （字节缓冲输入流）和（字节缓冲输入流），内部都维护了一个字节数组作为缓冲区。不过，前者主要是用来操作字符信息")]),v._v(" "),_("h3",{attrs:{id:"打印流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#打印流"}},[v._v("#")]),v._v(" 打印流")]),v._v(" "),_("p",[_("code",[v._v("System.out")]),v._v(" 实际是用于获取一个 "),_("code",[v._v("PrintStream")]),v._v(" 对象，"),_("code",[v._v("print")]),v._v("方法实际调用的是 "),_("code",[v._v("PrintStream")]),v._v(" 对象的 "),_("code",[v._v("write")]),v._v(" 方法。")]),v._v(" "),_("p",[_("code",[v._v("PrintStream")]),v._v(" 属于字节打印流，与之对应的是 "),_("code",[v._v("PrintWriter")]),v._v(" （字符打印流）。"),_("code",[v._v("PrintStream")]),v._v(" 是 "),_("code",[v._v("OutputStream")]),v._v(" 的子类，"),_("code",[v._v("PrintWriter")]),v._v(" 是 "),_("code",[v._v("Writer")]),v._v(" 的子类。")]),v._v(" "),_("h3",{attrs:{id:"随机访问流"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#随机访问流"}},[v._v("#")]),v._v(" 随机访问流")]),v._v(" "),_("p",[v._v("随机访问流指的是支持随意跳转到文件的任意位置进行读写的 "),_("code",[v._v("RandomAccessFile")]),v._v(" 。")]),v._v(" "),_("p",[v._v("读写模式主要有下面四种：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("r")]),v._v(" : 只读模式。")]),v._v(" "),_("li",[_("code",[v._v("rw")]),v._v(": 读写模式")]),v._v(" "),_("li",[_("code",[v._v("rws")]),v._v(": 相对于 "),_("code",[v._v("rw")]),v._v("，"),_("code",[v._v("rws")]),v._v(" 同步更新对“文件的内容”或“元数据”的修改到外部存储设备。")]),v._v(" "),_("li",[_("code",[v._v("rwd")]),v._v(" : 相对于 "),_("code",[v._v("rw")]),v._v("，"),_("code",[v._v("rwd")]),v._v(" 同步更新对“文件的内容”的修改到外部存储设备。")])]),v._v(" "),_("p",[v._v("文件内容指的是文件中实际保存的数据，元数据则是用来描述文件属性比如文件的大小信息、创建和修改时间。")]),v._v(" "),_("p",[_("code",[v._v("RandomAccessFile")]),v._v(" 中有一个文件指针用来表示下一个将要被写入或者读取的字节所处的位置。我们可以通过 "),_("code",[v._v("RandomAccessFile")]),v._v(" 的 "),_("code",[v._v("seek(long pos)")]),v._v(" 方法来设置文件指针的偏移量（距文件开头 "),_("code",[v._v("pos")]),v._v(" 个字节处）。如果想要获取文件指针当前的位置的话，可以使用 "),_("code",[v._v("getFilePointer()")]),v._v(" 方法")]),v._v(" "),_("p",[_("code",[v._v("RandomAccessFile")]),v._v(" 的 "),_("code",[v._v("write")]),v._v(" 方法在写入对象的时候如果对应的位置已经有数据的话，会将其覆盖掉。")]),v._v(" "),_("p",[_("code",[v._v("RandomAccessFile")]),v._v(" 比较常见的一个应用就是实现大文件的 "),_("strong",[v._v("断点续传")]),v._v(" 。何谓断点续传？简单来说就是上传文件中途暂停或失败（比如遇到网络问题）之后，不需要重新上传，只需要上传那些未成功上传的文件分片即可。分片（先将文件切分成多个文件分片）上传是断点续传的基础。")]),v._v(" "),_("p",[_("code",[v._v("RandomAccessFile")]),v._v(" 可以帮助我们合并文件分片。")]),v._v(" "),_("p",[_("code",[v._v("RandomAccessFile")]),v._v(" 的实现依赖于 "),_("code",[v._v("FileDescriptor")]),v._v(" (文件描述符) 和 "),_("code",[v._v("FileChannel")]),v._v(" （内存映射文件）。")]),v._v(" "),_("h3",{attrs:{id:"java-io设计模式总结"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-io设计模式总结"}},[v._v("#")]),v._v(" Java/IO设计模式总结")]),v._v(" "),_("h4",{attrs:{id:"装饰器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#装饰器模式"}},[v._v("#")]),v._v(" 装饰器模式")]),v._v(" "),_("p",[_("strong",[v._v("装饰器（Decorator）模式")]),v._v(" 可以在不改变原有对象的情况下拓展其功能。")]),v._v(" "),_("p",[v._v("装饰器模式通过组合替代继承来扩展原始类的功能，在一些继承关系比较复杂的场景（IO 这一场景各种类的继承关系就比较复杂）更加实用。")]),v._v(" "),_("p",[v._v("对于字节流来说， "),_("code",[v._v("FilterInputStream")]),v._v(" （对应输入流）和"),_("code",[v._v("FilterOutputStream")]),v._v("（对应输出流）是装饰器模式的核心，分别用于增强 "),_("code",[v._v("InputStream")]),v._v(" 和"),_("code",[v._v("OutputStream")]),v._v("子类对象的功能。")]),v._v(" "),_("p",[v._v("我们常见的"),_("code",[v._v("BufferedInputStream")]),v._v("(字节缓冲输入流)、"),_("code",[v._v("DataInputStream")]),v._v(" 等等都是"),_("code",[v._v("FilterInputStream")]),v._v(" 的子类，"),_("code",[v._v("BufferedOutputStream")]),v._v("（字节缓冲输出流）、"),_("code",[v._v("DataOutputStream")]),v._v("等等都是"),_("code",[v._v("FilterOutputStream")]),v._v("的子类。")]),v._v(" "),_("p",[v._v("这也是装饰器模式很重要的一个特征，那就是可以对原始类嵌套使用多个装饰器。")]),v._v(" "),_("p",[v._v("为了实现这一效果，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。上面介绍到的这些 IO 相关的装饰类和原始类共同的父类是 "),_("code",[v._v("InputStream")]),v._v(" 和"),_("code",[v._v("OutputStream")]),v._v("。")]),v._v(" "),_("p",[v._v("对于字符流来说，"),_("code",[v._v("BufferedReader")]),v._v(" 可以用来增加 "),_("code",[v._v("Reader")]),v._v(" （字符输入流）子类的功能，"),_("code",[v._v("BufferedWriter")]),v._v(" 可以用来增加 "),_("code",[v._v("Writer")]),v._v(" （字符输出流）子类的功能。")]),v._v(" "),_("p",[v._v("IO 流中的装饰器模式应用的例子实在是太多了，不需要特意记忆，完全没必要哈！搞清了装饰器模式的核心之后，你在使用的时候自然就会知道哪些地方运用到了装饰器模式。")]),v._v(" "),_("h4",{attrs:{id:"适配器模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#适配器模式"}},[v._v("#")]),v._v(" 适配器模式")]),v._v(" "),_("p",[_("strong",[v._v("适配器（Adapter Pattern）模式")]),v._v(" 主要用于接口互不兼容的类的协调工作，你可以将其联想到我们日常经常使用的电源适配器。")]),v._v(" "),_("p",[v._v("适配器模式中存在被适配的对象或者类称为 "),_("strong",[v._v("适配者(Adaptee)")]),v._v(" ，作用于适配者的对象或者类称为"),_("strong",[v._v("适配器(Adapter)")]),v._v(" 。适配器分为对象适配器和类适配器。类适配器使用继承关系来实现，对象适配器使用组合关系来实现。")]),v._v(" "),_("p",[v._v("IO 流中的字符流和字节流的接口不同，它们之间可以协调工作就是基于适配器模式来做的，更准确点来说是对象适配器。通过适配器，我们可以将字节流对象适配成一个字符流对象，这样我们可以直接通过字节流对象来读取或者写入字符数据。")]),v._v(" "),_("p",[_("code",[v._v("InputStreamReader")]),v._v(" 和 "),_("code",[v._v("OutputStreamWriter")]),v._v(" 就是两个适配器(Adapter)， 同时，它们两个也是字节流和字符流之间的桥梁。"),_("code",[v._v("InputStreamReader")]),v._v(" 使用 "),_("code",[v._v("StreamDecoder")]),v._v(" （流解码器）对字节进行解码，"),_("strong",[v._v("实现字节流到字符流的转换，")]),v._v(" "),_("code",[v._v("OutputStreamWriter")]),v._v(" 使用"),_("code",[v._v("StreamEncoder")]),v._v("（流编码器）对字符进行编码，实现字符流到字节流的转换。")]),v._v(" "),_("p",[_("code",[v._v("InputStream")]),v._v(" 和 "),_("code",[v._v("OutputStream")]),v._v(" 的子类是被适配者， "),_("code",[v._v("InputStreamReader")]),v._v(" 和 "),_("code",[v._v("OutputStreamWriter")]),v._v("是适配器。")]),v._v(" "),_("p",[_("strong",[v._v("适配器模式和装饰器模式有什么区别呢？")])]),v._v(" "),_("p",[_("strong",[v._v("装饰器模式")]),v._v(" 更侧重于动态地增强原始类的功能，装饰器类需要跟原始类继承相同的抽象类或者实现相同的接口。并且，装饰器模式支持对原始类嵌套使用多个装饰器。")]),v._v(" "),_("p",[_("strong",[v._v("适配器模式")]),v._v(" 更侧重于让接口不兼容而不能交互的类可以一起工作，当我们调用适配器对应的方法时，适配器内部会调用适配者类或者和适配类相关的类的方法，这个过程透明的。就比如说 "),_("code",[v._v("StreamDecoder")]),v._v(" （流解码器）和"),_("code",[v._v("StreamEncoder")]),v._v("（流编码器）就是分别基于 "),_("code",[v._v("InputStream")]),v._v(" 和 "),_("code",[v._v("OutputStream")]),v._v(" 来获取 "),_("code",[v._v("FileChannel")]),v._v("对象并调用对应的 "),_("code",[v._v("read")]),v._v(" 方法和 "),_("code",[v._v("write")]),v._v(" 方法进行字节数据的读取和写入。")]),v._v(" "),_("p",[v._v("适配器和适配者两者不需要继承相同的抽象类或者实现相同的接口。")]),v._v(" "),_("p",[v._v("另外，"),_("code",[v._v("FutrueTask")]),v._v(" 类使用了适配器模式，"),_("code",[v._v("Executors")]),v._v(" 的内部类 "),_("code",[v._v("RunnableAdapter")]),v._v(" 实现属于适配器，用于将 "),_("code",[v._v("Runnable")]),v._v(" 适配成 "),_("code",[v._v("Callable")]),v._v("。")]),v._v(" "),_("h4",{attrs:{id:"工厂模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#工厂模式"}},[v._v("#")]),v._v(" 工厂模式")]),v._v(" "),_("p",[v._v("工厂模式用于创建对象，NIO 中大量用到了工厂模式 .")]),v._v(" "),_("h4",{attrs:{id:"观察者模式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#观察者模式"}},[v._v("#")]),v._v(" 观察者模式")]),v._v(" "),_("p",[v._v("NIO 中的文件目录监听服务使用到了观察者模式。")]),v._v(" "),_("p",[v._v("NIO 中的文件目录监听服务基于 "),_("code",[v._v("WatchService")]),v._v(" 接口和 "),_("code",[v._v("Watchable")]),v._v(" 接口。"),_("code",[v._v("WatchService")]),v._v(" 属于观察者，"),_("code",[v._v("Watchable")]),v._v(" 属于被观察者。")]),v._v(" "),_("p",[_("code",[v._v("Watchable")]),v._v(" 接口定义了一个用于将对象注册到 "),_("code",[v._v("WatchService")]),v._v("（监控服务） 并绑定监听事件的方法 "),_("code",[v._v("register")]),v._v(" 。")]),v._v(" "),_("p",[_("code",[v._v("WatchService")]),v._v(" 用于监听文件目录的变化，同一个 "),_("code",[v._v("WatchService")]),v._v(" 对象能够监听多个文件目录。")]),v._v(" "),_("p",[_("code",[v._v("Path")]),v._v(" 类 "),_("code",[v._v("register")]),v._v(" 方法的第二个参数 "),_("code",[v._v("events")]),v._v(" （需要监听的事件）为可变长参数，也就是说我们可以同时监听多种事件。")]),v._v(" "),_("p",[v._v("常用的监听事件有 3 种：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("StandardWatchEventKinds.ENTRY_CREATE")]),v._v(" ：文件创建。")]),v._v(" "),_("li",[_("code",[v._v("StandardWatchEventKinds.ENTRY_DELETE")]),v._v(" : 文件删除。")]),v._v(" "),_("li",[_("code",[v._v("StandardWatchEventKinds.ENTRY_MODIFY")]),v._v(" : 文件修改。")])]),v._v(" "),_("p",[_("code",[v._v("register")]),v._v(" 方法返回 "),_("code",[v._v("WatchKey")]),v._v(" 对象，通过"),_("code",[v._v("WatchKey")]),v._v(" 对象可以获取事件的具体信息比如文件目录下是创建、删除还是修改了文件、创建、删除或者修改的文件的具体名称是什么。")]),v._v(" "),_("p",[_("code",[v._v("WatchService")]),v._v(" 内部是通过一个 daemon thread（守护线程）采用定期轮询的方式来检测文件的变化 .")]),v._v(" "),_("h3",{attrs:{id:"java-io模型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-io模型"}},[v._v("#")]),v._v(" Java/IO模型")]),v._v(" "),_("h4",{attrs:{id:"何为i-o"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#何为i-o"}},[v._v("#")]),v._v(" 何为I/O?")]),v._v(" "),_("p",[v._v("I/O（"),_("strong",[v._v("I")]),v._v("nput/"),_("strong",[v._v("O")]),v._v("utpu） 即"),_("strong",[v._v("输入／输出")]),v._v(" 。")]),v._v(" "),_("p",[_("strong",[v._v("我们先从计算机结构的角度来解读一下 I/O。")])]),v._v(" "),_("p",[v._v("根据冯.诺依曼结构，计算机结构分为 5 大部分：运算器、控制器、存储器、输入设备、输出设备。")]),v._v(" "),_("p",[v._v("输入设备（比如键盘）和输出设备（比如显示器）都属于外部设备。网卡、硬盘这种既可以属于输入设备，也可以属于输出设备。")]),v._v(" "),_("p",[v._v("输入设备向计算机输入数据，输出设备接收计算机输出的数据。")]),v._v(" "),_("p",[_("strong",[v._v("从计算机结构的视角来看的话， I/O 描述了计算机系统与外部设备之间通信的过程。")])]),v._v(" "),_("p",[_("strong",[v._v("我们再先从应用程序的角度来解读一下 I/O。")])]),v._v(" "),_("p",[v._v("根据大学里学到的操作系统相关的知识：为了保证操作系统的稳定性和安全性，一个进程的地址空间划分为 "),_("strong",[v._v("用户空间（User space）")]),v._v(" 和 "),_("strong",[v._v("内核空间（Kernel space ）")]),v._v(" 。")]),v._v(" "),_("p",[v._v("像我们平常运行的应用程序都是运行在用户空间，只有内核空间才能进行系统态级别的资源有关的操作，比如文件管理、进程通信、内存管理等等。也就是说，我们想要进行 IO 操作，一定是要依赖内核空间的能力。")]),v._v(" "),_("p",[v._v("并且，用户空间的程序不能直接访问内核空间。")]),v._v(" "),_("p",[v._v("当想要执行 IO 操作时，由于没有执行这些操作的权限，只能发起系统调用请求操作系统帮忙完成。")]),v._v(" "),_("p",[v._v("因此，用户进程想要执行 IO 操作的话，必须通过 "),_("strong",[v._v("系统调用")]),v._v(" 来间接访问内核空间")]),v._v(" "),_("p",[v._v("我们在平常开发过程中接触最多的就是 "),_("strong",[v._v("磁盘 IO（读写文件）")]),v._v(" 和 "),_("strong",[v._v("网络 IO（网络请求和响应）")]),v._v("。")]),v._v(" "),_("p",[_("strong",[v._v("从应用程序的视角来看的话，我们的应用程序对操作系统的内核发起 IO 调用（系统调用），操作系统负责的内核执行具体的 IO 操作。也就是说，我们的应用程序实际上只是发起了 IO 操作的调用而已，具体 IO 的执行是由操作系统的内核来完成的。")])]),v._v(" "),_("p",[v._v("当应用程序发起 I/O 调用后，会经历两个步骤：")]),v._v(" "),_("ol",[_("li",[v._v("内核等待 I/O 设备准备好数据")]),v._v(" "),_("li",[v._v("内核将数据从内核空间拷贝到用户空间")])])])}),[],!1,null,null,null);_.default=r.exports}}]);