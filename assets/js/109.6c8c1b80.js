(window.webpackJsonp=window.webpackJsonp||[]).push([[109],{570:function(s,a,t){"use strict";t.r(a);var v=t(1),e=Object(v.a)({},(function(){var s=this,a=s._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[a("h2",{attrs:{id:"面向对象基础"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象基础"}},[s._v("#")]),s._v(" 面向对象基础")]),s._v(" "),a("h3",{attrs:{id:"面向对象和面向过程的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象和面向过程的区别"}},[s._v("#")]),s._v(" 面向对象和面向过程的区别")]),s._v(" "),a("p",[s._v("两者的主要区别在于解决问题的方式不同：")]),s._v(" "),a("ul",[a("li",[s._v("面向过程把解决问题的过程拆成一个个方法，通过一个个方法的执行解决问题。")]),s._v(" "),a("li",[s._v("面向对象会先抽象出对象，然后用对象执行方法的方式解决问题。")])]),s._v(" "),a("p",[s._v("另外，面向对象开发的程序一般更易维护、易复用、易扩展。")]),s._v(" "),a("h3",{attrs:{id:"创建一个对象用什么运算符-对象实体与对象引用有何不同"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#创建一个对象用什么运算符-对象实体与对象引用有何不同"}},[s._v("#")]),s._v(" 创建一个对象用什么运算符?对象实体与对象引用有何不同?")]),s._v(" "),a("p",[s._v("new 运算符，new 创建对象实例（对象实例在堆内存中），对象引用指向对象实例（对象引用存放在栈内存中）。")]),s._v(" "),a("p",[s._v("一个对象引用可以指向 0 个或 1 个对象（一根绳子可以不系气球，也可以系一个气球）;一个对象可以有 n 个引用指向它（可以用 n 条绳子系住一个气球）。")]),s._v(" "),a("h3",{attrs:{id:"对象的相等和引用相等的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#对象的相等和引用相等的区别"}},[s._v("#")]),s._v(" 对象的相等和引用相等的区别")]),s._v(" "),a("ul",[a("li",[s._v("对象的相等一般比较的是内存中存放的内容是否相等。")]),s._v(" "),a("li",[s._v("引用相等一般比较的是他们指向的内存地址是否相等。")])]),s._v(" "),a("h3",{attrs:{id:"类的构造方法的作用是什么"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#类的构造方法的作用是什么"}},[s._v("#")]),s._v(" 类的构造方法的作用是什么?")]),s._v(" "),a("p",[s._v("构造方法是一种特殊的方法，主要作用是完成对象的初始化工作。")]),s._v(" "),a("h3",{attrs:{id:"如果一个类没有声明构造方法-该程序能正确执行吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#如果一个类没有声明构造方法-该程序能正确执行吗"}},[s._v("#")]),s._v(" 如果一个类没有声明构造方法，该程序能正确执行吗?")]),s._v(" "),a("p",[s._v("如果一个类没有声明构造方法，也可以执行！因为一个类即使没有声明构造方法也会有默认的不带参数的构造方法。如果我们自己添加了类的构造方法（无论是否有参），Java 就不会再添加默认的无参数的构造方法了，我们一直在不知不觉地使用构造方法，这也是为什么我们在创建对象的时候后面要加一个括号（因为要调用无参的构造方法）。如果我们重载了有参的构造方法，记得都要把无参的构造方法也写出来（无论是否用到），因为这可以帮助我们在创建对象的时候少踩坑")]),s._v(" "),a("h3",{attrs:{id:"构造方法有哪些特点-是否可被-override"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#构造方法有哪些特点-是否可被-override"}},[s._v("#")]),s._v(" 构造方法有哪些特点？是否可被 override?")]),s._v(" "),a("p",[s._v("构造方法特点如下：")]),s._v(" "),a("ul",[a("li",[s._v("名字与类名相同。")]),s._v(" "),a("li",[s._v("没有返回值，但不能用 void 声明构造函数。")]),s._v(" "),a("li",[s._v("生成类的对象时自动执行，无需调用。")])]),s._v(" "),a("p",[s._v("构造方法不能被 override（重写）,但是可以 overload（重载）,所以你可以看到一个类中有多个构造函数的情况。")]),s._v(" "),a("h3",{attrs:{id:"面向对象三大特征"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#面向对象三大特征"}},[s._v("#")]),s._v(" 面向对象三大特征")]),s._v(" "),a("h4",{attrs:{id:"封装"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#封装"}},[s._v("#")]),s._v(" 封装")]),s._v(" "),a("p",[s._v("封装是指把一个对象的状态信息（也就是属性）隐藏在对象内部，不允许外部对象直接访问对象的内部信息。但是可以提供一些可以被外界访问的方法来操作属性。就好像我们看不到挂在墙上的空调的内部的零件信息（也就是属性），但是可以通过遥控器（方法）来控制空调。如果属性不想被外界访问，我们大可不必提供方法给外界访问。但是如果一个类没有提供给外界访问的方法，那么这个类也没有什么意义了。")]),s._v(" "),a("h4",{attrs:{id:"继承"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#继承"}},[s._v("#")]),s._v(" 继承")]),s._v(" "),a("p",[s._v("不同类型的对象，相互之间经常有一定数量的共同点。例如，小明同学、小红同学、小李同学，都共享学生的特性（班级、学号等）。同时，每一个对象还定义了额外的特性使得他们与众不同。例如小明的数学比较好，小红的性格惹人喜爱；小李的力气比较大。继承是使用已存在的类的定义作为基础建立新类的技术，新类的定义可以增加新的数据或新的功能，也可以用父类的功能，但不能选择性地继承父类。通过使用继承，可以快速地创建新的类，可以提高代码的重用，程序的可维护性，节省大量创建新类的时间 ，提高我们的开发效率。")]),s._v(" "),a("p",[a("strong",[s._v("关于继承如下 3 点请记住：")])]),s._v(" "),a("ol",[a("li",[s._v("子类拥有父类对象所有的属性和方法（包括私有属性和私有方法），但是父类中的私有属性和方法子类是无法访问，"),a("strong",[s._v("只是拥有")]),s._v("。")]),s._v(" "),a("li",[s._v("子类可以拥有自己属性和方法，即子类可以对父类进行扩展。")]),s._v(" "),a("li",[s._v("子类可以用自己的方式实现父类的方法")])]),s._v(" "),a("h4",{attrs:{id:"多态"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#多态"}},[s._v("#")]),s._v(" 多态")]),s._v(" "),a("p",[s._v("多态，顾名思义，表示一个对象具有多种的状态，具体表现为父类的引用指向子类的实例。")]),s._v(" "),a("p",[a("strong",[s._v("多态的特点:")])]),s._v(" "),a("ul",[a("li",[s._v("对象类型和引用类型之间具有继承（类）/实现（接口）的关系；")]),s._v(" "),a("li",[s._v("引用类型变量发出的方法调用的到底是哪个类中的方法，必须在程序运行期间才能确定；")]),s._v(" "),a("li",[s._v("多态不能调用“只在子类存在但在父类不存在”的方法；")]),s._v(" "),a("li",[s._v("如果子类重写了父类的方法，真正执行的是子类覆盖的方法，如果子类没有覆盖父类的方法，执行的是父类的方法")])]),s._v(" "),a("h3",{attrs:{id:"接口和抽象类有什么共同点和区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#接口和抽象类有什么共同点和区别"}},[s._v("#")]),s._v(" 接口和抽象类有什么共同点和区别？")]),s._v(" "),a("p",[a("strong",[s._v("共同点")]),s._v(" ：")]),s._v(" "),a("ul",[a("li",[s._v("都不能被实例化。")]),s._v(" "),a("li",[s._v("都可以包含抽象方法。")]),s._v(" "),a("li",[s._v("都可以有默认实现的方法（Java 8 可以用 "),a("code",[s._v("default")]),s._v(" 关键字在接口中定义默认方法）。")])]),s._v(" "),a("p",[a("strong",[s._v("区别")]),s._v(" ：")]),s._v(" "),a("ul",[a("li",[s._v("接口主要用于对类的行为进行约束，你实现了某个接口就具有了对应的行为。抽象类主要用于代码复用，强调的是所属关系。")]),s._v(" "),a("li",[s._v("一个类只能继承一个类，但是可以实现多个接口。")]),s._v(" "),a("li",[s._v("接口中的成员变量只能是 "),a("code",[s._v("public static final")]),s._v(" 类型的，不能被修改且必须有初始值，而抽象类的成员变量默认 default，可在子类中被重新定义，也可被重新赋值。")])]),s._v(" "),a("h3",{attrs:{id:"深拷贝和浅拷贝区别了解吗-什么是引用拷贝"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#深拷贝和浅拷贝区别了解吗-什么是引用拷贝"}},[s._v("#")]),s._v(" 深拷贝和浅拷贝区别了解吗？什么是引用拷贝？")]),s._v(" "),a("p",[s._v("关于深拷贝和浅拷贝区别，我这里先给结论：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("浅拷贝")]),s._v("：浅拷贝会在堆上创建一个新的对象（区别于引用拷贝的一点），不过，如果原对象内部的属性是引用类型的话，浅拷贝会直接复制内部对象的引用地址，也就是说拷贝对象和原对象共用同一个内部对象。")]),s._v(" "),a("li",[a("strong",[s._v("深拷贝")]),s._v(" ：深拷贝会完全复制整个对象，包括这个对象所包含的内部对象。")])]),s._v(" "),a("h2",{attrs:{id:"java常见类object"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java常见类object"}},[s._v("#")]),s._v(" Java常见类Object")]),s._v(" "),a("h3",{attrs:{id:"object-类的常见方法有哪些"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#object-类的常见方法有哪些"}},[s._v("#")]),s._v(" Object 类的常见方法有哪些？")]),s._v(" "),a("div",{staticClass:"language-java line-numbers-mode"},[a("pre",{pre:!0,attrs:{class:"language-java"}},[a("code",[a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native 方法，用于返回当前运行时对象的 Class 对象，使用了 final 关键字修饰，故不允许子类重写。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Class")]),a("span",{pre:!0,attrs:{class:"token generics"}},[a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("<")]),a("span",{pre:!0,attrs:{class:"token operator"}},[s._v("?")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(">")])]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("getClass")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native 方法，用于返回对象的哈希码，主要使用在哈希表中，比如 JDK 中的HashMap。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("hashCode")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 用于比较 2 个对象的内存地址是否相等，String 类对该方法进行了重写以用于比较字符串的值是否相等。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("boolean")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("equals")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" obj"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * naitive 方法，用于创建并返回当前对象的一份拷贝。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("protected")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Object")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("clone")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("CloneNotSupportedException")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 返回类的名字实例的哈希码的 16 进制的字符串。建议 Object 所有的子类都重写这个方法。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("String")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("toString")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native 方法，并且不能重写。唤醒一个在此对象监视器上等待的线程(监视器相当于就是锁的概念)。如果有多个线程在等待只会任意唤醒一个。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("notify")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native 方法，并且不能重写。跟 notify 一样，唯一的区别就是会唤醒在此对象监视器上等待的所有线程，而不是一个线程。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("notifyAll")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * native方法，并且不能重写。暂停线程的执行。注意：sleep 方法没有释放锁，而 wait 方法释放了锁 ，timeout 是等待时间。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("native")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("wait")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" timeout"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InterruptedException")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 多了 nanos 参数，这个参数表示额外时间（以毫微秒为单位，范围是 0-999999）。 所以超时的时间还需要加上 nanos 毫秒。。\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("wait")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("long")]),s._v(" timeout"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(",")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("int")]),s._v(" nanos"),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InterruptedException")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 跟之前的2个wait方法一样，只不过该方法一直等待，没有超时时间这个概念\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("public")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("final")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("wait")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("InterruptedException")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token comment"}},[s._v("/**\n * 实例被垃圾回收器回收的时候触发的操作\n */")]),s._v("\n"),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("protected")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("void")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token function"}},[s._v("finalize")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("(")]),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v(")")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token keyword"}},[s._v("throws")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token class-name"}},[s._v("Throwable")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("{")]),s._v(" "),a("span",{pre:!0,attrs:{class:"token punctuation"}},[s._v("}")]),s._v("\n")])]),s._v(" "),a("div",{staticClass:"line-numbers-wrapper"},[a("span",{staticClass:"line-number"},[s._v("1")]),a("br"),a("span",{staticClass:"line-number"},[s._v("2")]),a("br"),a("span",{staticClass:"line-number"},[s._v("3")]),a("br"),a("span",{staticClass:"line-number"},[s._v("4")]),a("br"),a("span",{staticClass:"line-number"},[s._v("5")]),a("br"),a("span",{staticClass:"line-number"},[s._v("6")]),a("br"),a("span",{staticClass:"line-number"},[s._v("7")]),a("br"),a("span",{staticClass:"line-number"},[s._v("8")]),a("br"),a("span",{staticClass:"line-number"},[s._v("9")]),a("br"),a("span",{staticClass:"line-number"},[s._v("10")]),a("br"),a("span",{staticClass:"line-number"},[s._v("11")]),a("br"),a("span",{staticClass:"line-number"},[s._v("12")]),a("br"),a("span",{staticClass:"line-number"},[s._v("13")]),a("br"),a("span",{staticClass:"line-number"},[s._v("14")]),a("br"),a("span",{staticClass:"line-number"},[s._v("15")]),a("br"),a("span",{staticClass:"line-number"},[s._v("16")]),a("br"),a("span",{staticClass:"line-number"},[s._v("17")]),a("br"),a("span",{staticClass:"line-number"},[s._v("18")]),a("br"),a("span",{staticClass:"line-number"},[s._v("19")]),a("br"),a("span",{staticClass:"line-number"},[s._v("20")]),a("br"),a("span",{staticClass:"line-number"},[s._v("21")]),a("br"),a("span",{staticClass:"line-number"},[s._v("22")]),a("br"),a("span",{staticClass:"line-number"},[s._v("23")]),a("br"),a("span",{staticClass:"line-number"},[s._v("24")]),a("br"),a("span",{staticClass:"line-number"},[s._v("25")]),a("br"),a("span",{staticClass:"line-number"},[s._v("26")]),a("br"),a("span",{staticClass:"line-number"},[s._v("27")]),a("br"),a("span",{staticClass:"line-number"},[s._v("28")]),a("br"),a("span",{staticClass:"line-number"},[s._v("29")]),a("br"),a("span",{staticClass:"line-number"},[s._v("30")]),a("br"),a("span",{staticClass:"line-number"},[s._v("31")]),a("br"),a("span",{staticClass:"line-number"},[s._v("32")]),a("br"),a("span",{staticClass:"line-number"},[s._v("33")]),a("br"),a("span",{staticClass:"line-number"},[s._v("34")]),a("br"),a("span",{staticClass:"line-number"},[s._v("35")]),a("br"),a("span",{staticClass:"line-number"},[s._v("36")]),a("br"),a("span",{staticClass:"line-number"},[s._v("37")]),a("br"),a("span",{staticClass:"line-number"},[s._v("38")]),a("br"),a("span",{staticClass:"line-number"},[s._v("39")]),a("br"),a("span",{staticClass:"line-number"},[s._v("40")]),a("br"),a("span",{staticClass:"line-number"},[s._v("41")]),a("br"),a("span",{staticClass:"line-number"},[s._v("42")]),a("br"),a("span",{staticClass:"line-number"},[s._v("43")]),a("br"),a("span",{staticClass:"line-number"},[s._v("44")]),a("br")])]),a("h3",{attrs:{id:"和-equals-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#和-equals-的区别"}},[s._v("#")]),s._v(" == 和 equals() 的区别")]),s._v(" "),a("p",[a("strong",[a("code",[s._v("==")])]),s._v(" 对于基本类型和引用类型的作用效果是不同的：")]),s._v(" "),a("ul",[a("li",[s._v("对于基本数据类型来说，"),a("code",[s._v("==")]),s._v(" 比较的是值。")]),s._v(" "),a("li",[s._v("对于引用数据类型来说，"),a("code",[s._v("==")]),s._v(" 比较的是对象的内存地址。")])]),s._v(" "),a("blockquote",[a("p",[s._v("因为 Java 只有值传递，所以，对于 == 来说，不管是比较基本数据类型，还是引用数据类型的变量，其本质比较的都是值，只是引用类型变量存的值是对象的地址。")])]),s._v(" "),a("p",[a("strong",[a("code",[s._v("equals()")])]),s._v(" 不能用于判断基本数据类型的变量，只能用来判断两个对象是否相等。"),a("code",[s._v("equals()")]),s._v("方法存在于"),a("code",[s._v("Object")]),s._v("类中，而"),a("code",[s._v("Object")]),s._v("类是所有类的直接或间接父类，因此所有的类都有"),a("code",[s._v("equals()")]),s._v("方法。")]),s._v(" "),a("p",[a("code",[s._v("equals()")]),s._v(" 方法存在两种使用情况：")]),s._v(" "),a("ul",[a("li",[a("strong",[s._v("类没有重写 "),a("code",[s._v("equals()")]),s._v("方法")]),s._v(" ：通过"),a("code",[s._v("equals()")]),s._v("比较该类的两个对象时，等价于通过“==”比较这两个对象，使用的默认是 "),a("code",[s._v("Object")]),s._v("类"),a("code",[s._v("equals()")]),s._v("方法。")]),s._v(" "),a("li",[a("strong",[s._v("类重写了 "),a("code",[s._v("equals()")]),s._v("方法")]),s._v(" ：一般我们都重写 "),a("code",[s._v("equals()")]),s._v("方法来比较两个对象中的属性是否相等；若它们的属性相等，则返回 true(即，认为这两个对象相等)。")])]),s._v(" "),a("p",[a("code",[s._v("String")]),s._v(" 中的 "),a("code",[s._v("equals")]),s._v(" 方法是被重写过的，因为 "),a("code",[s._v("Object")]),s._v(" 的 "),a("code",[s._v("equals")]),s._v(" 方法是比较的对象的内存地址，而 "),a("code",[s._v("String")]),s._v(" 的 "),a("code",[s._v("equals")]),s._v(" 方法比较的是对象的值。")]),s._v(" "),a("p",[s._v("当创建 "),a("code",[s._v("String")]),s._v(" 类型的对象时，虚拟机会在常量池中查找有没有已经存在的值和要创建的值相同的对象，如果有就把它赋给当前引用。如果没有就在常量池中重新创建一个 "),a("code",[s._v("String")]),s._v(" 对象。")]),s._v(" "),a("h3",{attrs:{id:"hashcode-有什么用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#hashcode-有什么用"}},[s._v("#")]),s._v(" hashCode() 有什么用？")]),s._v(" "),a("p",[a("code",[s._v("hashCode()")]),s._v(" 的作用是获取哈希码（"),a("code",[s._v("int")]),s._v(" 整数），也称为散列码。这个哈希码的作用是确定该对象在哈希表中的索引位置。")]),s._v(" "),a("p",[a("code",[s._v("hashCode()")]),s._v("定义在 JDK 的 "),a("code",[s._v("Object")]),s._v(" 类中，这就意味着 Java 中的任何类都包含有 "),a("code",[s._v("hashCode()")]),s._v(" 函数。另外需要注意的是： "),a("code",[s._v("Object")]),s._v(" 的 "),a("code",[s._v("hashCode()")]),s._v(" 方法是本地方法，也就是用 C 语言或 C++ 实现的，该方法通常用来将对象的内存地址转换为整数之后返回。")]),s._v(" "),a("p",[s._v("散列表存储的是键值对(key-value)，它的特点是："),a("strong",[s._v("能根据“键”快速的检索出对应的“值”。这其中就利用到了散列码！（可以快速找到所需要的对象）")])]),s._v(" "),a("h3",{attrs:{id:"为什么要有-hashcode"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么要有-hashcode"}},[s._v("#")]),s._v(" 为什么要有 hashCode？")]),s._v(" "),a("p",[s._v("我们以“"),a("code",[s._v("HashSet")]),s._v(" 如何检查重复”为例子来说明为什么要有 "),a("code",[s._v("hashCode")]),s._v("？")]),s._v(" "),a("blockquote",[a("p",[s._v("当你把对象加入 "),a("code",[s._v("HashSet")]),s._v(" 时，"),a("code",[s._v("HashSet")]),s._v(" 会先计算对象的 "),a("code",[s._v("hashCode")]),s._v(" 值来判断对象加入的位置，同时也会与其他已经加入的对象的 "),a("code",[s._v("hashCode")]),s._v(" 值作比较，如果没有相符的 "),a("code",[s._v("hashCode")]),s._v("，"),a("code",[s._v("HashSet")]),s._v(" 会假设对象没有重复出现。但是如果发现有相同 "),a("code",[s._v("hashCode")]),s._v(" 值的对象，这时会调用 "),a("code",[s._v("equals()")]),s._v(" 方法来检查 "),a("code",[s._v("hashCode")]),s._v(" 相等的对象是否真的相同。如果两者相同，"),a("code",[s._v("HashSet")]),s._v(" 就不会让其加入操作成功。如果不同的话，就会重新散列到其他位置。这样我们就大大减少了 "),a("code",[s._v("equals")]),s._v(" 的次数，相应就大大提高了执行速度.")])]),s._v(" "),a("p",[s._v("总结：")]),s._v(" "),a("ul",[a("li",[a("p",[s._v("如果两个对象的"),a("code",[s._v("hashCode")]),s._v(" 值相等，那这两个对象不一定相等（哈希碰撞）。")])]),s._v(" "),a("li",[a("p",[s._v("如果两个对象的"),a("code",[s._v("hashCode")]),s._v(" 值相等并且"),a("code",[s._v("equals()")]),s._v("方法也返回 "),a("code",[s._v("true")]),s._v("，我们才认为这两个对象相等。")])]),s._v(" "),a("li",[a("p",[s._v("如果两个对象的"),a("code",[s._v("hashCode")]),s._v(" 值不相等，我们就可以直接认为这两个对象不相等。")])])]),s._v(" "),a("h3",{attrs:{id:"为什么重写-equals-时必须重写-hashcode-方法"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#为什么重写-equals-时必须重写-hashcode-方法"}},[s._v("#")]),s._v(" 为什么重写 equals() 时必须重写 hashCode() 方法？")]),s._v(" "),a("p",[s._v("因为两个相等的对象的 "),a("code",[s._v("hashCode")]),s._v(" 值必须是相等。也就是说如果 "),a("code",[s._v("equals")]),s._v(" 方法判断两个对象是相等的，那这两个对象的 "),a("code",[s._v("hashCode")]),s._v(" 值也要相等。")]),s._v(" "),a("p",[s._v("如果重写 "),a("code",[s._v("equals()")]),s._v(" 时没有重写 "),a("code",[s._v("hashCode()")]),s._v(" 方法的话就可能会导致 "),a("code",[s._v("equals")]),s._v(" 方法判断是相等的两个对象，"),a("code",[s._v("hashCode")]),s._v(" 值却不相等。")]),s._v(" "),a("p",[a("strong",[s._v("思考")]),s._v(" ：重写 "),a("code",[s._v("equals()")]),s._v(" 时没有重写 "),a("code",[s._v("hashCode()")]),s._v(" 方法的话，使用 "),a("code",[s._v("HashMap")]),s._v(" 可能会出现什么问题。")]),s._v(" "),a("p",[a("strong",[s._v("总结")]),s._v(" ：")]),s._v(" "),a("ul",[a("li",[a("code",[s._v("equals")]),s._v(" 方法判断两个对象是相等的，那这两个对象的 "),a("code",[s._v("hashCode")]),s._v(" 值也要相等。")]),s._v(" "),a("li",[s._v("两个对象有相同的 "),a("code",[s._v("hashCode")]),s._v(" 值，他们也不一定是相等的（哈希碰撞）。")])]),s._v(" "),a("h2",{attrs:{id:"java常见类string"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#java常见类string"}},[s._v("#")]),s._v(" Java常见类String")]),s._v(" "),a("h3",{attrs:{id:"string、stringbuffer、stringbuilder-的区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string、stringbuffer、stringbuilder-的区别"}},[s._v("#")]),s._v(" String、StringBuffer、StringBuilder 的区别？")]),s._v(" "),a("p",[a("strong",[s._v("可变性")])]),s._v(" "),a("p",[a("code",[s._v("String")]),s._v(" 是不可变的.( "),a("code",[s._v("String")]),s._v(" 类中使用 "),a("code",[s._v("final")]),s._v(" 关键字修饰字符数组来保存字符串 )")]),s._v(" "),a("p",[a("code",[s._v("StringBuilder")]),s._v(" 与 "),a("code",[s._v("StringBuffer")]),s._v(" 都继承自 "),a("code",[s._v("AbstractStringBuilder")]),s._v(" 类，在 "),a("code",[s._v("AbstractStringBuilder")]),s._v(" 中也是使用字符数组保存字符串，不过没有使用 "),a("code",[s._v("final")]),s._v(" 和 "),a("code",[s._v("private")]),s._v(" 关键字修饰，最关键的是这个 "),a("code",[s._v("AbstractStringBuilder")]),s._v(" 类还提供了很多修改字符串的方法比如 "),a("code",[s._v("append")]),s._v(" 方法。")]),s._v(" "),a("p",[a("strong",[s._v("线程安全性")])]),s._v(" "),a("p",[a("code",[s._v("String")]),s._v(" 中的对象是不可变的，也就可以理解为常量，线程安全。"),a("code",[s._v("AbstractStringBuilder")]),s._v(" 是 "),a("code",[s._v("StringBuilder")]),s._v(" 与 "),a("code",[s._v("StringBuffer")]),s._v(" 的公共父类，定义了一些字符串的基本操作，如 "),a("code",[s._v("expandCapacity")]),s._v("、"),a("code",[s._v("append")]),s._v("、"),a("code",[s._v("insert")]),s._v("、"),a("code",[s._v("indexOf")]),s._v(" 等公共方法。"),a("code",[s._v("StringBuffer")]),s._v(" 对方法加了同步锁或者对调用的方法加了同步锁，所以是线程安全的。"),a("code",[s._v("StringBuilder")]),s._v(" 并没有对方法进行加同步锁，所以是非线程安全的。")]),s._v(" "),a("p",[a("strong",[s._v("性能")])]),s._v(" "),a("p",[s._v("每次对 "),a("code",[s._v("String")]),s._v(" 类型进行改变的时候，都会生成一个新的 "),a("code",[s._v("String")]),s._v(" 对象，然后将指针指向新的 "),a("code",[s._v("String")]),s._v(" 对象。"),a("code",[s._v("StringBuffer")]),s._v(" 每次都会对 "),a("code",[s._v("StringBuffer")]),s._v(" 对象本身进行操作，而不是生成新的对象并改变对象引用。相同情况下使用 "),a("code",[s._v("StringBuilder")]),s._v(" 相比使用 "),a("code",[s._v("StringBuffer")]),s._v(" 仅能获得 10%~15% 左右的性能提升，但却要冒多线程不安全的风险。")]),s._v(" "),a("p",[a("strong",[s._v("对于三者使用的总结：")])]),s._v(" "),a("ol",[a("li",[s._v("操作少量的数据: 适用 "),a("code",[s._v("String")])]),s._v(" "),a("li",[s._v("单线程操作字符串缓冲区下操作大量数据: 适用 "),a("code",[s._v("StringBuilder")])]),s._v(" "),a("li",[s._v("多线程操作字符串缓冲区下操作大量数据: 适用 "),a("code",[s._v("StringBuffer")])])]),s._v(" "),a("h3",{attrs:{id:"string-equals-和-object-equals-有何区别"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-equals-和-object-equals-有何区别"}},[s._v("#")]),s._v(" String#equals() 和 Object#equals() 有何区别？")]),s._v(" "),a("p",[a("code",[s._v("String")]),s._v(" 中的 "),a("code",[s._v("equals")]),s._v(" 方法是被重写过的，比较的是 String 字符串的值是否相等。 "),a("code",[s._v("Object")]),s._v(" 的 "),a("code",[s._v("equals")]),s._v(" 方法是比较的对象的内存地址。")]),s._v(" "),a("h4",{attrs:{id:"字符串常量池的作用了解吗"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#字符串常量池的作用了解吗"}},[s._v("#")]),s._v(" 字符串常量池的作用了解吗？")]),s._v(" "),a("p",[a("strong",[s._v("字符串常量池")]),s._v(" 是 JVM 为了提升性能和减少内存消耗针对字符串（String 类）专门开辟的一块区域，主要目的是为了避免字符串的重复创建。")]),s._v(" "),a("h4",{attrs:{id:"string-s1-new-string-abc-这句话创建了几个字符串对象"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#string-s1-new-string-abc-这句话创建了几个字符串对象"}},[s._v("#")]),s._v(' String s1 = new String("abc");这句话创建了几个字符串对象？')]),s._v(" "),a("p",[s._v("会创建 1 或 2 个字符串对象。")]),s._v(" "),a("p",[s._v("1、如果字符串常量池中不存在字符串对象“abc”的引用，那么会在堆中创建 2 个字符串对象“abc”。")]),s._v(" "),a("p",[a("code",[s._v("ldc")]),s._v(" 命令可以判断字符串常量池中是否保存了对应的字符串对象的引用，如果保存了的话直接返回，如果没有保存的话，会在堆中创建对应的字符串对象并将该字符串对象的引用保存到字符串常量池中。")]),s._v(" "),a("p",[s._v("2、如果字符串常量池中已存在字符串对象“abc”的引用，则只会在堆中创建 1 个字符串对象“abc”。")]),s._v(" "),a("h3",{attrs:{id:"intern-方法有什么作用"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#intern-方法有什么作用"}},[s._v("#")]),s._v(" intern 方法有什么作用?")]),s._v(" "),a("p",[a("code",[s._v("String.intern()")]),s._v(" 是一个 native（本地）方法，其作用是将指定的字符串对象的引用保存在字符串常量池中，可以简单分为两种情况：")]),s._v(" "),a("ul",[a("li",[s._v("如果字符串常量池中保存了对应的字符串对象的引用，就直接返回该引用。")]),s._v(" "),a("li",[s._v("如果字符串常量池中没有保存了对应的字符串对象的引用，那就在常量池中创建一个指向该字符串对象的引用并返回。")])]),s._v(" "),a("p",[s._v("String 类型的变量和常量做“+”运算时发生了什么？")]),s._v(" "),a("p",[a("strong",[s._v("对于编译期可以确定值的字符串，也就是常量字符串 ，jvm 会将其存入字符串常量池。并且，字符串常量拼接得到的字符串常量在编译阶段就已经被存放字符串常量池，这个得益于编译器的优化。")])]),s._v(" "),a("p",[s._v("在编译过程中，Javac 编译器（下文中统称为编译器）会进行一个叫做 "),a("strong",[s._v("常量折叠(Constant Folding)")]),s._v(" 的代码优化 .常量折叠会把常量表达式的值求出来作为常量嵌在最终生成的代码中，这是 Javac 编译器会对源代码做的极少量优化措施之一(代码优化几乎都在即时编译器中进行)。")]),s._v(" "),a("p",[s._v("对于 "),a("code",[s._v('String str3 = "str" + "ing";')]),s._v(" 编译器会给你优化成 "),a("code",[s._v('String str3 = "string";')]),s._v(" 。")]),s._v(" "),a("p",[s._v("并不是所有的常量都会进行折叠，只有编译器在程序编译期就可以确定值的常量才可以：")]),s._v(" "),a("ul",[a("li",[s._v("基本数据类型( "),a("code",[s._v("byte")]),s._v("、"),a("code",[s._v("boolean")]),s._v("、"),a("code",[s._v("short")]),s._v("、"),a("code",[s._v("char")]),s._v("、"),a("code",[s._v("int")]),s._v("、"),a("code",[s._v("float")]),s._v("、"),a("code",[s._v("long")]),s._v("、"),a("code",[s._v("double")]),s._v(")以及字符串常量。")]),s._v(" "),a("li",[a("code",[s._v("final")]),s._v(" 修饰的基本数据类型和字符串变量")]),s._v(" "),a("li",[s._v("字符串通过 “+”拼接得到的字符串、基本数据类型之间算数运算（加减乘除）、基本数据类型的位运算（<<、>>、>>> ）")])]),s._v(" "),a("p",[a("strong",[s._v("引用的值在程序编译期是无法确定的，编译器无法对其进行优化。")])]),s._v(" "),a("p",[s._v("对象引用和“+”的字符串拼接方式，实际上是通过 "),a("code",[s._v("StringBuilder")]),s._v(" 调用 "),a("code",[s._v("append()")]),s._v(" 方法实现的，拼接完成之后调用 "),a("code",[s._v("toString()")]),s._v(" 得到一个 "),a("code",[s._v("String")]),s._v(" 对象 。")]),s._v(" "),a("p",[s._v("我们在平时写代码的时候，尽量避免多个字符串对象拼接，因为这样会重新创建对象。如果需要改变字符串的话，可以使用 "),a("code",[s._v("StringBuilder")]),s._v(" 或者 "),a("code",[s._v("StringBuffer")]),s._v("。")]),s._v(" "),a("p",[s._v("不过，字符串使用 "),a("code",[s._v("final")]),s._v(" 关键字声明之后，可以让编译器当做常量来处理。")]),s._v(" "),a("p",[s._v("被 "),a("code",[s._v("final")]),s._v(" 关键字修改之后的 "),a("code",[s._v("String")]),s._v(" 会被编译器当做常量来处理，编译器在程序编译期就可以确定它的值，其效果就相当于访问常量。")]),s._v(" "),a("p",[s._v("如果 ，编译器在运行时才能知道其确切值的话，就无法对其优化。")])])}),[],!1,null,null,null);a.default=e.exports}}]);