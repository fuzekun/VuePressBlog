(window.webpackJsonp=window.webpackJsonp||[]).push([[238],{699:function(l,e,p){"use strict";p.r(e);var _=p(1),v=Object(_.a)({},(function(){var l=this,e=l._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":l.$parent.slotKey}},[e("p",[l._v("（1）select==>时间复杂度O(n)")]),l._v(" "),e("p",[l._v("它仅仅知道了，有I/O事件发生了，却并不知道是哪几个流（可能有一个，多个，甚至全部），我们只能无差别轮询所有流，找出能读出数据，或者写入数据的流，对他们进行操作。所以"),e("code",[l._v("select具有O(n)的无差别轮询复杂度")]),l._v("，同时处理的流越多，无差别轮询时间就越长。")]),l._v(" "),e("p",[l._v("（2）poll==>时间复杂度O(n)")]),l._v(" "),e("p",[l._v("poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态， "),e("code",[l._v("但是它没有最大连接数的限制，原因是它是基于链表来存储的。")])]),l._v(" "),e("p",[l._v("（3）epoll==>时间复杂度O(1)")]),l._v(" "),e("p",[l._v("epoll可以理解为event poll，不同于忙轮询和无差别轮询，epoll会把哪个流发生了怎样的I/O事件通知我们。"),e("code",[l._v("所以我们说epoll实际上是事件驱动（每个事件关联上fd：进程独有的文件描述表的索引）的")]),l._v("，此时我们对这些流的操作都是有意义的。（复杂度降低到了O(1)）")]),l._v(" "),e("p",[l._v("select，poll，epoll都是IO多路复用的机制。I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。"),e("strong",[l._v("但select，poll，epoll本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，也就是说这个读写过程是阻塞的")]),l._v(",而异步I/O则无需自己负责进行读写，异步I/O的实现会负责把数据从内核拷贝到用户空间。")]),l._v(" "),e("p",[l._v("epoll跟select都能提供多路I/O复用的解决方案。在现在的Linux内核里有都能够支持，其中epoll是Linux所特有，而select则应该是POSIX所规定，一般操作系统均有实现。")]),l._v(" "),e("p",[e("strong",[l._v("select：")])]),l._v(" "),e("p",[l._v("select本质上是通过设置或者检查存放fd标志位的数据结构来进行下一步处理。这样所带来的缺点是：")]),l._v(" "),e("p",[l._v("1、 单个进程可监视的fd数量被限制，即能监听端口的大小有限。\n一般来说这个数目和系统内存关系很大，具体数目可以cat /proc/sys/fs/file-max察看。32位机默认是1024个。64位机默认是2048.")]),l._v(" "),e("p",[l._v("2、 对socket进行扫描时是线性扫描，即采用轮询的方法，效率较低：\n当套接字比较多的时候，每次select()都要通过遍历FD_SETSIZE个Socket来完成调度,不管哪个Socket是活跃的,都遍历一遍。这会浪费很多CPU时间。如果能给套接字注册某个回调函数，当他们活跃时，自动完成相关操作，那就避免了轮询，这正是epoll与kqueue做的。")]),l._v(" "),e("p",[l._v("3、需要维护一个用来存放大量fd的数据结构，这样会使得用户空间和内核空间在传递该结构时复制开销大")]),l._v(" "),e("p",[e("strong",[l._v("poll：")])]),l._v(" "),e("p",[l._v("poll本质上和select没有区别，它将用户传入的数组拷贝到内核空间，然后查询每个fd对应的设备状态，如果设备就绪则在设备等待队列中加入一项并继续遍历，如果遍历完所有fd后没有发现就绪设备，则挂起当前进程，直到设备就绪或者主动超时，被唤醒后它又要再次遍历fd。这个过程经历了多次无谓的遍历。")]),l._v(" "),e("p",[l._v("它没有最大连接数的限制，原因是它是基于链表来存储的，但是同样有一个缺点：")]),l._v(" "),e("p",[l._v("1、大量的fd的数组被整体复制于用户态和内核地址空间之间，而不管这样的复制是不是有意义。")]),l._v(" "),e("p",[l._v("2、poll还有一个特点是“水平触发”，如果报告了fd后，没有被处理，那么下次poll时会再次报告该fd。")]),l._v(" "),e("p",[e("strong",[l._v("epoll:")])]),l._v(" "),e("p",[l._v("epoll有EPOLLLT和EPOLLET两种触发模式，LT是默认的模式，ET是“高速”模式。LT模式下，只要这个fd还有数据可读，每次 epoll_wait都会返回它的事件，提醒用户程序去操作，而在ET（边缘触发）模式中，它只会提示一次，直到下次再有数据流入之前都不会再提示了，无 论fd中是否还有数据可读。所以在ET模式下，read一个fd的时候一定要把它的buffer读光，也就是说一直读到read的返回值小于请求值，或者 遇到EAGAIN错误。还有一个特点是，epoll使用“事件”的就绪通知方式，通过epoll_ctl注册fd，一旦该fd就绪，内核就会采用类似callback的回调机制来激活该fd，epoll_wait便可以收到通知。")])])}),[],!1,null,null,null);e.default=v.exports}}]);