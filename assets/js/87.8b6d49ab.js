(window.webpackJsonp=window.webpackJsonp||[]).push([[87],{548:function(a,s,t){"use strict";t.r(s);var _=t(1),e=Object(_.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"遇到内存泄露-怎么解决"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#遇到内存泄露-怎么解决"}},[a._v("#")]),a._v(" 遇到内存泄露，怎么解决？")]),a._v(" "),s("p",[a._v("1、内存泄露memory leak：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露似乎不会有太大的影响。")]),a._v(" "),s("p",[a._v("2、内存溢出 out of memory :指程序申请内存时，没有足够的内存供申请者使用，或者说，给了你一块存储int类型数据的存储空间，但是你却存储long类型的数据，那么结果就是内存不够用，此时就会报错OOM,即所谓的内存溢出。 但是内存泄露堆积后的后果就是内存溢出；")]),a._v(" "),s("h3",{attrs:{id:"java中的内存管理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java中的内存管理"}},[a._v("#")]),a._v(" Java中的内存管理")]),a._v(" "),s("p",[a._v("要了解Java中的内存泄露，首先就得知道Java中的内存是如何管理的。")]),a._v(" "),s("p",[a._v("在Java程序中，我们通常使用new为对象分配内存，而这些内存空间都在堆（Heap）上。")]),a._v(" "),s("p",[a._v("下面看一个示例：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/fb126d9c618e4bbd9c20bbf71ea4c34a.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_17,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("在有向图中，我们叫作obj1是可达的，obj2就是不可达的，"),s("code",[a._v("显然不可达的可以被清理")]),a._v(".")]),a._v(" "),s("p",[a._v("** 内存的释放，也即清理那些不可达的对象**，是由GC决定和执行的，所以GC会监控每一个对象的状态，包括申请、引用、被引用和赋值等。"),s("strong",[a._v("释放对象的根本原则就是对象不会再被使用")]),a._v("：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("给对象赋予了空值null，之后再没有调用过。")])]),a._v(" "),s("li",[s("p",[a._v("另一个是给对象赋予了新值，这样重新分配了内存空间。")])])]),a._v(" "),s("p",[a._v("通常，会认为在堆上分配对象的代价比较大，但是GC却优化了这一操作：C++中，在堆上分配一块内存，会查找一块适用的内存加以分配，如果对象销毁，这块内存就可以重用；而Java中，就想一条长的带子，每分配一个新的对象，Java的“堆指针”就向后移动到尚未分配的区域。所以，Java分配内存的效率，可与C++媲美。")]),a._v(" "),s("p",[a._v("但是这种工作方式有一个问题：如果频繁的申请内存，资源将会耗尽。这时GC就介入了进来，它会回收空间，并使堆中的对象排列更紧凑。这样，就始终会有足够大的内存空间可以分配。")]),a._v(" "),s("h3",{attrs:{id:"java中的内存泄露"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java中的内存泄露"}},[a._v("#")]),a._v(" Java中的内存泄露")]),a._v(" "),s("p",[a._v("Java中的内存泄露，广义并通俗的说，就是："),s("code",[a._v("不再会被使用的对象的内存不能被回收，就是内存泄露")]),a._v("。")]),a._v(" "),s("p",[a._v("Java中的内存泄露与C++中的表现有所不同。")]),a._v(" "),s("p",[a._v("在C++中，所有被分配了内存的对象，不再使用后，都必须程序员手动的释放他们。所以，每个类，都会含有一个析构函数，作用就是完成清理工作，如果我们忘记了某些对象的释放，就会造成内存泄露。")]),a._v(" "),s("p",[a._v("但是在Java中，我们不用（也没办法）自己释放内存，无用的对象由GC自动清理，这也极大的简化了我们的编程工作。但，实际有时候一些不再会被使用的对象，在GC看来不能被释放，就会造成内存泄露。")]),a._v(" "),s("p",[a._v("我们知道，对象都是有生命周期的，有的长，有的短，"),s("code",[a._v("如果长生命周期的对象持有短生命周期的引用，就很可能会出现内存泄露")]),a._v("。我们举一个简单的例子：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/1616be36f3204c848df3019097387860.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_16,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("这里的object实例，其实我们期望它只作用于method1()方法中，且其他地方不会再用到它，但是，当method1()方法执行完成后，object对象所分配的内存不会马上被认为是可以被释放的对象，只有在Simple类创建的对象被释放后才会被释放，严格的说，这就是一种内存泄露。解决方法就是将object作为method1()方法中的局部变量。当然，如果一定要这么写，可以改为这样：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/4a4e9ef4a0ce482fb691415bec62c4a4.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_16,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("这样，之前“new Object()”分配的内存，就可以被GC回收。")]),a._v(" "),s("p",[a._v("到这里，Java的内存泄露应该都比较清楚了。下面再进一步说明：")]),a._v(" "),s("ul",[s("li",[s("p",[a._v("在堆中的分配的内存，在没有将其释放掉的时候，就将所有能访问这块内存的方式都删掉（如指针重新赋值），这是针对c++等语言的，Java中的GC会帮我们处理这种情况，所以我们无需关心。")])]),a._v(" "),s("li",[s("p",[s("code",[a._v("在内存对象明明已经不需要的时候，还仍然保留着这块内存和它的访问方式（引用），这是所有语言都有可能会出现的内存泄漏方式")]),a._v("。编程时如果不小心，我们很容易发生这种情况，如果不太严重，可能就只是短暂的内存泄露。")])])]),a._v(" "),s("h3",{attrs:{id:"一些容易引发内存泄露的例子和解决方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一些容易引发内存泄露的例子和解决方法"}},[a._v("#")]),a._v(" 一些容易引发内存泄露的例子和解决方法")]),a._v(" "),s("p",[a._v("像上面例子中的情况很容易发生，也是我们最容易忽略并引发内存泄露的情况，"),s("strong",[a._v("解决的原则就是尽量减小对象的作用域")]),a._v("（比如android studio中，上面的代码就会发出警告，并给出的建议是将类的成员变量改写为方法内的局部变量）以及手动设置null值。")]),a._v(" "),s("h4",{attrs:{id:"容器使用时的内存泄露"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#容器使用时的内存泄露"}},[a._v("#")]),a._v(" 容器使用时的内存泄露")]),a._v(" "),s("p",[a._v("在很多文章中可能看到一个如下内存泄露的例子：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/85afbabc4d844af3a99330e9aae5fd99.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_17,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("可能很多人一开始并不理解，下面我们将上面的代码完整下就好理解了：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/e2e8b74439304c1985f6f6cb11373447.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_16,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("这里内存泄露指的是在对vector操作完成之后，执行下面与vector无关的代码时，如果发生了GC操作，这一系列的object是没法被回收的，而此处的内存泄露可能是短暂的，因为在整个method()方法执行完成后，那些对象还是可以被回收。这里要解决很简单，手动赋值为null即可：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/cfb7553bcfbc4dfebf40f5927df673cd.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_13,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("上面Vector已经过时了，不过只是使用老的例子来做内存泄露的介绍。我们使用容器时很容易发生内存泄露，就如上面的例子，不过上例中，容器是方法内的局部变量，造成的内存泄漏影响可能不算很大（但我们也应该避免），但是，"),s("strong",[a._v("如果这个容器作为一个类的成员变量，甚至是一个静态（static）的成员变量时，就要更加注意内存泄露了。")])]),a._v(" "),s("p",[a._v("下面也是一种使用容器时可能会发生的错误:")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/e1ef9ba1e2df4440b6fdf04aba804239.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_20,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("运行上面的代码将很快报错：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/c040b132d1ee4ee991b38597d8b28706.png",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("容器Set只存放唯一的元素，是通过对象的equals()方法来比较的，但是Java中所有类都直接或间接继承至Object类，Object类的equals()方法比较的是对象的地址，上例中，就会一直添加元素直到内存溢出。")]),a._v(" "),s("p",[a._v("所以，上例严格的说是容器的错误使用导致的内存溢出。")]),a._v(" "),s("p",[a._v("就Set而言，remove()方法也是通过equals()方法来删除匹配的元素的，如果一个对象确实提供了正确的equals()方法，但是"),s("code",[a._v("切记不要在修改这个对象后使用remove(Object o)，这也可能会发生内存泄露")]),a._v("。")]),a._v(" "),s("p",[s("strong",[a._v("各种提供了close()方法的对象")])]),a._v(" "),s("p",[a._v("比如数据库连接（dataSourse.getConnection()），网络连接(socket)和io连接，以及使用其他框架的时候，除非其显式的调用了其close()方法（或类似方法）将其连接关闭，否则是不会自动被GC回收的。其实原因依然是长生命周期对象持有短生命周期对象的引用。")]),a._v(" "),s("p",[a._v("可能很多人使用过Hibernate，我们操作数据库时，通过SessionFactory获取一个session：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Session")]),a._v(" session"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v("sessionFactory"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("openSession")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("完成后我们必须要调用close()方法关闭：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("session"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("close")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("SessionFactory就是一个长生命周期的对象，而session相对是个短生命周期的对象，但是框架这么设计是合理的：它并不清楚我们要使用session到多久，于是只能提供一个方法让我们自己决定何时不再使用。")]),a._v(" "),s("p",[a._v("因为在close()方法调用之前，可能会抛出异常而导致方法不能被调用，我们通常使用try语言，然后再finally语句中执行close()等清理工作：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/db9466f8d72747bfafc65a4ba459d582.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_17,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[s("strong",[a._v("单例模式导致的内存泄露")])]),a._v(" "),s("p",[a._v("单例模式，"),s("code",[a._v("很多时候我们可以把它的生命周期与整个程序的生命周期看做差不多的，所以是一个长生命周期的对象。如果这个对象持有其他对象的引用，也很容易发生内存泄露")]),a._v("。")]),a._v(" "),s("h3",{attrs:{id:"与清理相关的方法"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#与清理相关的方法"}},[a._v("#")]),a._v(" 与清理相关的方法")]),a._v(" "),s("p",[s("strong",[a._v("gc()")])]),a._v(" "),s("p",[s("strong",[a._v("对于程序员来说，GC基本是透明的，不可见的")]),a._v("。运行GC的函数是System.gc()，调用后启动垃圾回收器开始清理。")]),a._v(" "),s("p",[a._v("但是根据Java语言规范定义， "),s("strong",[a._v("该函数不保证JVM的垃圾收集器一定会执行")]),a._v("。因为，不同的JVM实现者可能使用不同的算法管理GC。通常，GC的线程的优先级别较低。")]),a._v(" "),s("p",[a._v("JVM调用GC的策略也有很多种，有的是内存使用到达一定程度时，GC才开始工作，也有定时执行的，有的是平缓执行GC，有的是中断式执行GC。但通常来说，我们不需要关心这些。除非在一些特定的场合，GC的执行影响应用程序的性能，例如对于基于Web的实时系统，如网络游戏等，用户不希望GC突然中断应用程序执行而进行垃圾回收，那么我们需要调整GC的参数，让GC能够通过平缓的方式释放内存，例如将垃圾回收分解为一系列的小步骤执行，Sun提供的HotSpot JVM就支持这一特性。")]),a._v(" "),s("p",[s("strong",[a._v("finalize()")])]),a._v(" "),s("p",[a._v("finalize()是Object类中的方法。")]),a._v(" "),s("p",[a._v("了解C++的都知道有个析构函数，但是注意，finalize()绝不等于C++中的析构函数。")]),a._v(" "),s("p",[a._v("Java编程思想中是这么解释的：一旦GC准备好释放对象所占用的的存储空间，将先调用其finalize()方法，并在下一次GC回收动作发生时，才会真正回收对象占用的内存，所以一些清理工作，我们可以放到finalize()中。")]),a._v(" "),s("p",[a._v("该方法的一个重要的用途是：当在java中调用非java代码（如c和c++）时，在这些非java代码中可能会用到相应的申请内存的操作（如c的malloc()函数），而在这些非java代码中并没有有效的释放这些内存，就可以使用finalize()方法，并在里面调用本地方法的free()等函数。")]),a._v(" "),s("p",[a._v("所以finalize()并不适合用作普通的清理工作。")]),a._v(" "),s("p",[a._v("不过有时候，该方法也有一定的用处：")]),a._v(" "),s("p",[a._v("如果存在一系列对象，对象中有一个状态为false，如果我们已经处理过这个对象，状态会变为true，为了避免有被遗漏而没有处理的对象，就可以使用finalize()方法：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/10a2fb0363f74382a1f8b8d2a159290d.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_19,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})])])}),[],!1,null,null,null);s.default=e.exports}}]);