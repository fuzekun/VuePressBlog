(window.webpackJsonp=window.webpackJsonp||[]).push([[77],{537:function(n,o,e){"use strict";e.r(o);var t=e(1),c=Object(t.a)({},(function(){var n=this,o=n._self._c;return o("ContentSlotsDistributor",{attrs:{"slot-key":n.$parent.slotKey}},[o("h3",{attrs:{id:"synchronized和lock的区别"}},[o("a",{staticClass:"header-anchor",attrs:{href:"#synchronized和lock的区别"}},[n._v("#")]),n._v(" synchronized和lock的区别？")]),n._v(" "),o("p",[n._v("1、synchronized是Java关键字级别的锁，在JDK1.6之前，synchronized锁的实现都是借助于调用操作系统的一些方法来实现的，而调用操作系统的方法，就难免导致计算机在用户态和核心态之间的频繁切换，会影响性能；而Lock是Java对象级别的锁，在进行调用时与操作系统无关，性能更好；")]),n._v(" "),o("p",[n._v("2、synchronized锁上锁之后不需要解锁，当锁住的内容执行完之后，会自动释放锁；而lock锁有上锁lock()方法和解锁unlock()方法；")]),n._v(" "),o("p",[n._v("3、synchronized锁是不可中断的锁，在唤醒其他线程时，要么随机唤醒一个线程，要么唤醒所有线程；而lock的锁可以绑定多个条件变量，进行有针对性的唤醒；")]),n._v(" "),o("p",[n._v("4、synchronized加的是非公平锁，而Reentrantlock加的锁可以是公平的也可以是非公平的，默认加的是非公平锁，如果想加公平锁，只需要在创建锁对象时传入一个boolean类型的参数即可，true为公平锁，false为非公平锁.")]),n._v(" "),o("p",[n._v("（扩展：Reentrantlock实现公平锁和非公平锁的区别就在于，当一个线程尝试获取锁时，公平锁会直接将该线程进行排队，如果此时等待队列中没有在等待的线程，则当前线程执行，否则，当前线程进入等待队列等待锁；而非公平锁则是不进行任何判断，当前线程直接尝试使用CAS操作获取锁。）")])])}),[],!1,null,null,null);o.default=c.exports}}]);