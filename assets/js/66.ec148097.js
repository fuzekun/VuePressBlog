(window.webpackJsonp=window.webpackJsonp||[]).push([[66],{527:function(t,a,s){"use strict";s.r(a);var r=s(1),n=Object(r.a)({},(function(){var t=this,a=t._self._c;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h3",{attrs:{id:"静态代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#静态代理"}},[t._v("#")]),t._v(" 静态代理")]),t._v(" "),a("p",[t._v("1、代理对象的一个接口只服务于一种类型的对象，如果需要代理的方法很多，势必需要为每一个方法都进行代理；")]),t._v(" "),a("p",[t._v("2、如果一个接口增加了一个方法，除了所有实现类需要实现这个方法外，所有的代理类也需要实现这个方法，增加了代码维护的复杂度。")]),t._v(" "),a("h3",{attrs:{id:"动态代理"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#动态代理"}},[t._v("#")]),t._v(" 动态代理")]),t._v(" "),a("p",[t._v("最大的好处是接口中的所有方法都被转移到调用处理器的一个集中的方法中处理（InvocationHandler中的invoke方法），在接口方法较多时可以灵活处理，动态代理的应用使类职责更加单一，复用性更强。")])])}),[],!1,null,null,null);a.default=n.exports}}]);