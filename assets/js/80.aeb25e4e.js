(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{540:function(_,v,e){"use strict";e.r(v);var t=e(1),a=Object(t.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"cms-以获取最短回收停顿时间为目标的收集器-基于并发-标记清理-实现"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#cms-以获取最短回收停顿时间为目标的收集器-基于并发-标记清理-实现"}},[_._v("#")]),_._v(" CMS：以获取最短回收停顿时间为目标的收集器，基于并发“标记清理”实现")]),_._v(" "),v("p",[_._v("为什么标记清理会产生内存碎片，但是CMS仍然采用标记清理算法？")]),_._v(" "),v("p",[_._v("因为CMS作为第一款实现用户线程和收集线程并发执行的收集器，当时的设计理念是减少停顿时间，最好能并发执行，但是问题来了，如果用户线程也在执行，那么就不能轻易改变堆中对象的内存地址，不然会导致用户线程无法定位引用对象，从而无法正常运行，而标记整理算法和复制算法都会移动存活的对象，所以只能采用标记清理算法。")]),_._v(" "),v("p",[v("strong",[_._v("初始标记  ---\x3e 并发标记 ----\x3e  重新标记  ----\x3e 并发清理")])]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/cba125b11b5649c2ae653f3b91856508.png",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[_._v("过程：")]),_._v(" "),v("p",[_._v("1）初始标记：独占CPU，STW，仅标记GCRoots能直接关联的对象；")]),_._v(" "),v("p",[_._v("2）并发标记：可以和用户线程并发执行，通过GCRoots Tracing标记所有可达对象；")]),_._v(" "),v("p",[_._v("3）重新标记：独占CPU，STW，对并发标记阶段用户线程运行产生的垃圾对象进行标记修改，以及更新自我拯救逃逸的那部分对象；")]),_._v(" "),v("p",[_._v("4）并发清理：可以和用户线程并发执行，清理垃圾。")]),_._v(" "),v("p",[_._v("优点：")]),_._v(" "),v("p",[v("code",[_._v("并发、低停顿")])]),_._v(" "),v("p",[_._v("缺点：")]),_._v(" "),v("p",[_._v("1、对CPU非常敏感：在并发阶段虽然不会导致用户线程停顿，但是会占用一部分线程使程序运行变慢；")]),_._v(" "),v("p",[_._v("2、无法处理浮动垃圾：在最后一次并发清理过程中，其他用户线程也可能会产生垃圾，但是这部分垃圾是在标记之后产生的，所以只有等下一次GC的时候才能清理，这部分就是浮动垃圾。由于并发清理的时候，用户线程也在运行，就需要保障用户线程在运行的时候需要留有部分内存以使用，就会出现一次“Concurrent Mode Failure”，一旦出现该错误，便会开启后备方案，临时使用SerialOld收集器进行收集工作。")]),_._v(" "),v("p",[_._v("3、CMS使用标记清理算法会产生大量的内存碎片，当碎片过多时，那些大的对象的空间分配就会造成麻烦，就可能会导致频繁的Full GC影响性能。")]),_._v(" "),v("p",[_._v("为了解决该问题，为CMS提供了一个开关参数，用于CMS在顶不住的时候，开启内存碎片的整理过程，但是开启整理过程的时候没有办法并发，会导致停顿时间增加。")]),_._v(" "),v("p",[_._v("CMS出现Full GC的原因：")]),_._v(" "),v("p",[_._v("1）年轻代在晋升老年代的时候没有连续的足够的空间，可能是由于内存碎片导致的该原因，因此会触发Full GC；")]),_._v(" "),v("p",[_._v("2）在并发过程中JVM会觉得在并发过程结束之前堆就会慢，需要提前触发Full GC。CMS失败后的备用方案是SerialOld收集器。")]),_._v(" "),v("h3",{attrs:{id:"g1是一款面向服务端应用的垃圾收集器"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#g1是一款面向服务端应用的垃圾收集器"}},[_._v("#")]),_._v(" G1是一款面向服务端应用的垃圾收集器")]),_._v(" "),v("p",[_._v("初始标记  ---\x3e 并发标记  ----\x3e 最终标记  ----\x3e 筛选回收")]),_._v(" "),v("p",[v("code",[_._v("G1只有并发标记阶段能做到用户线程和收集线程并发执行")]),_._v("。")]),_._v(" "),v("p",[v("code",[_._v("G1不需要其他收集器配合就能独立管理整个GC堆。G1的目标是替换CMS")]),_._v("。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/03bb021239404fa9b602571fd2a2efee.png",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[_._v("特点：")]),_._v(" "),v("p",[_._v("1、"),v("code",[_._v("并行与并发")]),_._v("：G1能充分利用CPU、多核环境下的硬件优势，使用多个CPU（CPU或者CPU核心）来缩短STW的停顿时间。部分其他收集器原本需要停顿Java线程执行的GC操作，G1收集器仍然可以通过并发的方式让Java程序继续运行；")]),_._v(" "),v("p",[_._v("2、"),v("code",[_._v("分代收集")]),_._v("：分代概念在G1中依然得以保留。虽然G1可以不需要其他收集器配合就能独立管理整个GC堆，但它能够采用不同的方式去吹了新创建的对象和已经存活了一段时间、熬过很多次GC的旧对象以获得更好的收集效果。也就是说G1可以自己管理新生代和老年代了；")]),_._v(" "),v("p",[_._v("3、"),v("code",[_._v("空间整合")]),_._v("，没有内存碎片产生：由于G1使用了独立区域（Region）概念，G1从整体来看是基于“标记-整理”算法实现收集，从局部（两个Region）上来看是基于“复制”算法实现的，但是无论如何，这两种算法都意味着G1的运作期间不会产生内存碎片。")]),_._v(" "),v("p",[_._v("4、在最后的筛选阶段，对每个Region里的回收价值进行排序，对垃圾最多的Region进行回收；")]),_._v(" "),v("p",[_._v("5、可预测的停顿：G1可以有计划的避免在Java整个堆中进行垃圾回收，可以对每个Region回收对象的价值进行分许，在最后的筛序回收阶段，对最有回收价值的Region进行回收。")]),_._v(" "),v("p",[_._v("为了避免扫描全堆，G1使用了Remembered Set来管理相关的对象引用信息。")]),_._v(" "),v("p",[v("code",[_._v("Serial Old（垃圾回收器：串行回收） parallel GC：吞吐量优先")]),_._v(" "),v("img",{attrs:{src:"https://img-blog.csdnimg.cn/0b05218ec3e043dc8991b4a486b85738.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_14,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),_._v(" "),v("p",[_._v("响应时间优先：CMS响应时间优先：CMS")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/d240c550f10a4a9d9c6883ef4e770c52.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_16,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})])])}),[],!1,null,null,null);v.default=a.exports}}]);