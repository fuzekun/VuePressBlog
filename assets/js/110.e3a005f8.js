(window.webpackJsonp=window.webpackJsonp||[]).push([[110],{571:function(v,_,t){"use strict";t.r(_);var e=t(1),a=Object(e.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"异常"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常"}},[v._v("#")]),v._v(" 异常")]),v._v(" "),_("h3",{attrs:{id:"exception-和-error-有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#exception-和-error-有什么区别"}},[v._v("#")]),v._v(" Exception 和 Error 有什么区别？")]),v._v(" "),_("p",[v._v("在 Java 中，所有的异常都有一个共同的祖先 "),_("code",[v._v("java.lang")]),v._v(" 包中的 "),_("code",[v._v("Throwable")]),v._v(" 类。"),_("code",[v._v("Throwable")]),v._v(" 类有两个重要的子类:")]),v._v(" "),_("ul",[_("li",[_("strong",[_("code",[v._v("Exception")])]),v._v(" :程序本身可以处理的异常，可以通过 "),_("code",[v._v("catch")]),v._v(" 来进行捕获。"),_("code",[v._v("Exception")]),v._v(" 又可以分为 Checked Exception (受检查异常，必须处理) 和 Unchecked Exception (不受检查异常，可以不处理)。")]),v._v(" "),_("li",[_("strong",[_("code",[v._v("Error")])]),v._v(" ："),_("code",[v._v("Error")]),v._v(" 属于程序无法处理的错误 ，我们没办法通过 "),_("code",[v._v("catch")]),v._v(" 来进行捕获不建议通过"),_("code",[v._v("catch")]),v._v("捕获 。例如 Java 虚拟机运行错误（"),_("code",[v._v("Virtual MachineError")]),v._v("）、虚拟机内存不够错误("),_("code",[v._v("OutOfMemoryError")]),v._v(")、类定义错误（"),_("code",[v._v("NoClassDefFoundError")]),v._v("）等 。这些异常发生时，Java 虚拟机（JVM）一般会选择线程终止。")])]),v._v(" "),_("h3",{attrs:{id:"checked-exception-和-unchecked-exception-有什么区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#checked-exception-和-unchecked-exception-有什么区别"}},[v._v("#")]),v._v(" Checked Exception 和 Unchecked Exception 有什么区别？")]),v._v(" "),_("p",[_("strong",[v._v("Checked Exception")]),v._v(" 即 受检查异常 ，Java 代码在编译过程中，如果受检查异常没有被 "),_("code",[v._v("catch")]),v._v("或者"),_("code",[v._v("throws")]),v._v(" 关键字处理的话，就没办法通过编译。")]),v._v(" "),_("p",[v._v("除了"),_("code",[v._v("RuntimeException``Exception``ClassNotFoundException``SQLException")])]),v._v(" "),_("p",[_("strong",[v._v("Unchecked Exception")]),v._v(" 即 "),_("strong",[v._v("不受检查异常")]),v._v(" ，Java 代码在编译过程中 ，我们即使不处理不受检查异常也可以正常通过编译。")]),v._v(" "),_("p",[_("code",[v._v("RuntimeException")]),v._v(" 及其子类都统称为非受检查异常，常见的有（日常开发中会经常用到）：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("NullPointerException")]),v._v("(空指针错误)")]),v._v(" "),_("li",[_("code",[v._v("IllegalArgumentException")]),v._v("(参数错误比如方法入参类型错误)")]),v._v(" "),_("li",[_("code",[v._v("NumberFormatException")]),v._v("（字符串转换为数字格式错误，"),_("code",[v._v("IllegalArgumentException")]),v._v("的子类）")]),v._v(" "),_("li",[_("code",[v._v("ArrayIndexOutOfBoundsException")]),v._v("（数组越界错误）")]),v._v(" "),_("li",[_("code",[v._v("ClassCastException")]),v._v("（类型转换错误）")]),v._v(" "),_("li",[_("code",[v._v("ArithmeticException")]),v._v("（算术错误）")]),v._v(" "),_("li",[_("code",[v._v("SecurityException")]),v._v(" （安全错误比如权限不够）")]),v._v(" "),_("li",[_("code",[v._v("UnsupportedOperationException")]),v._v("(不支持的操作错误比如重复创建同一用户)")]),v._v(" "),_("li",[v._v("......")])]),v._v(" "),_("h3",{attrs:{id:"throwable-类常用方法有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#throwable-类常用方法有哪些"}},[v._v("#")]),v._v(" Throwable 类常用方法有哪些？")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("String getMessage()")]),v._v(": 返回异常发生时的简要描述")]),v._v(" "),_("li",[_("code",[v._v("String toString()")]),v._v(": 返回异常发生时的详细信息")]),v._v(" "),_("li",[_("code",[v._v("String getLocalizedMessage()")]),v._v(": 返回异常对象的本地化信息。使用 "),_("code",[v._v("Throwable")]),v._v(" 的子类覆盖这个方法，可以生成本地化信息。如果子类没有覆盖该方法，则该方法返回的信息与 "),_("code",[v._v("getMessage()")]),v._v("返回的结果相同")]),v._v(" "),_("li",[_("code",[v._v("void printStackTrace()")]),v._v(": 在控制台上打印 "),_("code",[v._v("Throwable")]),v._v(" 对象封装的异常信息")])]),v._v(" "),_("h3",{attrs:{id:"try-catch-finally-如何使用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#try-catch-finally-如何使用"}},[v._v("#")]),v._v(" try-catch-finally 如何使用？")]),v._v(" "),_("ul",[_("li",[_("p",[_("code",[v._v("try")]),v._v("块 ： 用于捕获异常。其后可接零个或多个 "),_("code",[v._v("catch")]),v._v(" 块，如果没有 "),_("code",[v._v("catch")]),v._v(" 块，则必须跟一个 "),_("code",[v._v("finally")]),v._v(" 块。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("catch")]),v._v("块 ： 用于处理 try 捕获到的异常。")])]),v._v(" "),_("li",[_("p",[_("code",[v._v("finally")]),v._v(" 块 ： 无论是否捕获或处理异常，"),_("code",[v._v("finally")]),v._v(" 块里的语句都会被执行。当在 "),_("code",[v._v("try")]),v._v(" 块或 "),_("code",[v._v("catch")]),v._v(" 块中遇到 "),_("code",[v._v("return")]),v._v(" 语句时，"),_("code",[v._v("finally")]),v._v(" 语句块将在方法返回之前被执行。")])])]),v._v(" "),_("p",[_("strong",[v._v("注意：不要在 finally 语句块中使用 return!")]),v._v(" 当 try 语句和 finally 语句中都有 return 语句时，try 语句块中的 return 语句会被忽略。这是因为 try 语句中的 return 返回值会先被暂存在一个本地变量中，当执行到 finally 语句中的 return 之后，这个本地变量的值就变为了 finally 语句中的 return 返回值。")]),v._v(" "),_("h3",{attrs:{id:"finally-中的代码一定会执行吗"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#finally-中的代码一定会执行吗"}},[v._v("#")]),v._v(" finally 中的代码一定会执行吗？")]),v._v(" "),_("p",[v._v("不一定的！在某些情况下，finally 中的代码不会被执行。")]),v._v(" "),_("p",[v._v("就比如说 finally 之前虚拟机被终止运行的话，finally 中的代码就不会被执行。")]),v._v(" "),_("p",[v._v("另外，在以下 2 种特殊情况下，"),_("code",[v._v("finally")]),v._v(" 块的代码也不会被执行：")]),v._v(" "),_("ol",[_("li",[v._v("程序所在的线程死亡。")]),v._v(" "),_("li",[v._v("关闭 CPU。")])]),v._v(" "),_("h3",{attrs:{id:"异常使用有哪些需要注意的地方"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#异常使用有哪些需要注意的地方"}},[v._v("#")]),v._v(" 异常使用有哪些需要注意的地方？")]),v._v(" "),_("ul",[_("li",[v._v("不要把异常定义为静态变量，因为这样会导致异常栈信息错乱。每次手动抛出异常，我们都需要手动 new 一个异常对象抛出。")]),v._v(" "),_("li",[v._v("抛出的异常信息一定要有意义。")]),v._v(" "),_("li",[v._v("建议抛出更加具体的异常比如字符串转换为数字格式错误的时候应该抛出"),_("code",[v._v("NumberFormatException")]),v._v("而不是父类"),_("code",[v._v("IllegalArgumentException")]),v._v("。")]),v._v(" "),_("li",[v._v("使用日志打印异常之后就不要再抛出异常了（两者不要同时存在一段代码逻辑中）。")])]),v._v(" "),_("h2",{attrs:{id:"泛型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#泛型"}},[v._v("#")]),v._v(" 泛型")]),v._v(" "),_("h3",{attrs:{id:"什么是泛型-有什么作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是泛型-有什么作用"}},[v._v("#")]),v._v(" 什么是泛型？有什么作用？")]),v._v(" "),_("p",[_("strong",[v._v("ava 泛型（Generics）")]),v._v(" 是 JDK 5 中引入的一个新特性。使用泛型参数，可以增强代码的可读性以及稳定性。")]),v._v(" "),_("p",[v._v("编译器可以对泛型参数进行检测，并且通过泛型参数可以指定传入的对象类型。比如 "),_("code",[v._v("ArrayList persons = new ArrayList()")]),v._v(" 这行代码就指明了该 "),_("code",[v._v("ArrayList")]),v._v(" 对象只能传入 "),_("code",[v._v("Person")]),v._v(" 对象，如果传入其他类型的对象就会报错。")]),v._v(" "),_("p",[v._v("并且，原生 "),_("code",[v._v("List")]),v._v(" 返回类型是 "),_("code",[v._v("Object")]),v._v(" ，需要手动转换类型才能使用，使用泛型后编译器自动转换。")]),v._v(" "),_("h3",{attrs:{id:"泛型的使用方式有哪几种"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#泛型的使用方式有哪几种"}},[v._v("#")]),v._v(" 泛型的使用方式有哪几种？")]),v._v(" "),_("p",[v._v("泛型一般有三种使用方式:"),_("strong",[v._v("泛型类")]),v._v("、"),_("strong",[v._v("泛型接口")]),v._v("、"),_("strong",[v._v("泛型方法")]),v._v("。")]),v._v(" "),_("h3",{attrs:{id:"项目中哪里用到了泛型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#项目中哪里用到了泛型"}},[v._v("#")]),v._v(" 项目中哪里用到了泛型？")]),v._v(" "),_("ul",[_("li",[v._v("自定义接口通用返回结果 "),_("code",[v._v("CommonResult")]),v._v(" 通过参数 "),_("code",[v._v("T")]),v._v(" 可根据具体的返回类型动态指定结果的数据类型")]),v._v(" "),_("li",[v._v("定义 "),_("code",[v._v("Excel")]),v._v(" 处理类 "),_("code",[v._v("ExcelUtil")]),v._v(" 用于动态指定 "),_("code",[v._v("Excel")]),v._v(" 导出的数据类型")]),v._v(" "),_("li",[v._v("构建集合工具类（参考 "),_("code",[v._v("Collections")]),v._v(" 中的 "),_("code",[v._v("sort")]),v._v(", "),_("code",[v._v("binarySearch")]),v._v(" 方法）。")])]),v._v(" "),_("h2",{attrs:{id:"反射"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反射"}},[v._v("#")]),v._v(" 反射")]),v._v(" "),_("h3",{attrs:{id:"何谓反射"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#何谓反射"}},[v._v("#")]),v._v(" 何谓反射？")]),v._v(" "),_("p",[v._v("如果说大家研究过框架的底层原理或者咱们自己写过框架的话，一定对反射这个概念不陌生。反射之所以被称为框架的灵魂，主要是因为它赋予了我们在运行时分析类以及执行类中方法的能力。通过反射你可以获取任意一个类的所有属性和方法，你还可以调用这些方法和属性")]),v._v(" "),_("h3",{attrs:{id:"反射的优缺点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反射的优缺点"}},[v._v("#")]),v._v(" 反射的优缺点？")]),v._v(" "),_("p",[v._v("反射可以让我们的代码更加灵活、为各种框架提供开箱即用的功能提供了便利。")]),v._v(" "),_("p",[v._v("不过，反射让我们在运行时有了分析操作类的能力的同时，也增加了安全问题，比如可以无视泛型参数的安全检查（泛型参数的安全检查发生在编译时）。另外，反射的性能也要稍差点，不过，对于框架来说实际是影响不大的。")]),v._v(" "),_("h3",{attrs:{id:"反射的应用场景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#反射的应用场景"}},[v._v("#")]),v._v(" 反射的应用场景？")]),v._v(" "),_("p",[v._v("像咱们平时大部分时候都是在写业务代码，很少会接触到直接使用反射机制的场景。但是！这并不代表反射没有用。相反，正是因为反射，你才能这么轻松地使用各种框架。像 Spring/Spring Boot、MyBatis 等等框架中都大量使用了反射机制。")]),v._v(" "),_("p",[_("strong",[v._v("这些框架中也大量使用了动态代理，而动态代理的实现也依赖反射。")])]),v._v(" "),_("p",[v._v("另外，像 Java 中的一大利器 "),_("strong",[v._v("注解")]),v._v(" 的实现也用到了反射。")]),v._v(" "),_("p",[v._v("为什么你使用 Spring 的时候 ，一个"),_("code",[v._v("@Component")]),v._v("注解就声明了一个类为 Spring Bean 呢？为什么你通过一个 "),_("code",[v._v("@Value")]),v._v("注解就读取到配置文件中的值呢？究竟是怎么起作用的呢？")]),v._v(" "),_("p",[v._v("这些都是因为你可以基于反射分析类，然后获取到类/属性/方法/方法的参数上的注解。你获取到注解之后，就可以做进一步的处理。")]),v._v(" "),_("h2",{attrs:{id:"注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注解"}},[v._v("#")]),v._v(" 注解")]),v._v(" "),_("h3",{attrs:{id:"何谓注解"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#何谓注解"}},[v._v("#")]),v._v(" 何谓注解")]),v._v(" "),_("p",[_("code",[v._v("Annotation")]),v._v(" （注解） 是 Java5 开始引入的新特性，可以看作是一种特殊的注释，主要用于修饰类、方法或者变量，提供某些信息供程序在编译或者运行时使用。")]),v._v(" "),_("p",[v._v("注解本质是一个继承了"),_("code",[v._v("Annotation")]),v._v(" 的特殊接口")]),v._v(" "),_("p",[v._v("JDK 提供了很多内置的注解（比如 "),_("code",[v._v("@Override")]),v._v(" 、"),_("code",[v._v("@Deprecated")]),v._v("），同时，我们还可以自定义注解。")]),v._v(" "),_("h3",{attrs:{id:"注解的解析方法有哪几种"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注解的解析方法有哪几种"}},[v._v("#")]),v._v(" 注解的解析方法有哪几种？")]),v._v(" "),_("p",[v._v("注解只有被解析之后才会生效，常见的解析方法有两种：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("编译期直接扫描")]),v._v(" ：编译器在编译 Java 代码的时候扫描对应的注解并处理，比如某个方法使用"),_("code",[v._v("@Override")]),v._v(" 注解，编译器在编译的时候就会检测当前的方法是否重写了父类对应的方法。")]),v._v(" "),_("li",[_("strong",[v._v("运行期通过反射处理")]),v._v(" ：像框架中自带的注解(比如 Spring 框架的 "),_("code",[v._v("@Value")]),v._v(" 、"),_("code",[v._v("@Component")]),v._v(")都是通过反射来进行处理的.")])]),v._v(" "),_("h2",{attrs:{id:"序列化和反序列化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#序列化和反序列化"}},[v._v("#")]),v._v(" 序列化和反序列化")]),v._v(" "),_("h3",{attrs:{id:"什么是序列化-什么是反序列化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是序列化-什么是反序列化"}},[v._v("#")]),v._v(" 什么是序列化?什么是反序列化?")]),v._v(" "),_("p",[v._v("如果我们需要持久化 Java 对象比如将 Java 对象保存在文件中，或者在网络传输 Java 对象，这些场景都需要用到序列化。")]),v._v(" "),_("p",[v._v("简单来说：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("序列化")]),v._v("： 将数据结构或对象转换成二进制字节流的过程")]),v._v(" "),_("li",[_("strong",[v._v("反序列化")]),v._v("：将在序列化过程中所生成的二进制字节流转换成数据结构或者对象的过程")])]),v._v(" "),_("p",[v._v("对于 Java 这种面向对象编程语言来说，我们序列化的都是对象（Object）也就是实例化后的类(Class)，但是在 C++这种半面向对象的语言中，struct(结构体)定义的是数据结构类型，而 class 对应的是对象类型。")]),v._v(" "),_("p",[v._v("下面是序列化和反序列化常见应用场景：")]),v._v(" "),_("ul",[_("li",[v._v("对象在进行网络传输（比如远程方法调用 RPC 的时候）之前需要先被序列化，接收到序列化的对象之后需要再进行反序列化；")]),v._v(" "),_("li",[v._v("将对象存储到文件之前需要进行序列化，将对象从文件中读取出来需要进行反序列化；")]),v._v(" "),_("li",[v._v("将对象存储到数据库（如 Redis）之前需要用到序列化，将对象从缓存数据库中读取出来需要反序列化；")]),v._v(" "),_("li",[v._v("将对象存储到内存之前需要进行序列化，从内存中读取出来之后需要进行反序列化。")])]),v._v(" "),_("p",[v._v("综上："),_("strong",[v._v("序列化的主要目的是通过网络传输对象或者说是将对象存储到文件系统、数据库、内存中。")])]),v._v(" "),_("p",[v._v("OSI 七层协议模型中，表示层做的事情主要就是对应用层的用户数据进行处理转换为二进制流。反过来的话，就是将二进制流转换成应用层的用户数据。这对应的就是序列化和反序列化.")]),v._v(" "),_("h3",{attrs:{id:"如果有些字段不想进行序列化怎么办"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如果有些字段不想进行序列化怎么办"}},[v._v("#")]),v._v(" 如果有些字段不想进行序列化怎么办？")]),v._v(" "),_("p",[v._v("对于不想进行序列化的变量，使用 "),_("code",[v._v("transient")]),v._v(" 关键字修饰。")]),v._v(" "),_("p",[_("code",[v._v("transient")]),v._v(" 关键字的作用是：阻止实例中那些用此关键字修饰的的变量序列化；当对象被反序列化时，被 "),_("code",[v._v("transient")]),v._v(" 修饰的变量值不会被持久化和恢复。")]),v._v(" "),_("p",[v._v("关于 "),_("code",[v._v("transient")]),v._v(" 还有几点注意：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("transient")]),v._v(" 只能修饰变量，不能修饰类和方法。")]),v._v(" "),_("li",[_("code",[v._v("transient")]),v._v(" 修饰的变量，在反序列化后变量值将会被置成类型的默认值。例如，如果是修饰 "),_("code",[v._v("int")]),v._v(" 类型，那么反序列后结果就是 "),_("code",[v._v("0")]),v._v("。")]),v._v(" "),_("li",[_("code",[v._v("static")]),v._v(" 变量因为不属于任何对象(Object)，所以无论有没有 "),_("code",[v._v("transient")]),v._v(" 关键字修饰，均不会被序列化")])]),v._v(" "),_("h3",{attrs:{id:"常见序列化协议有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#常见序列化协议有哪些"}},[v._v("#")]),v._v(" 常见序列化协议有哪些？")]),v._v(" "),_("p",[v._v("JDK 自带的序列化方式一般不会用 ，因为序列化效率低并且存在安全问题。比较常用的序列化协议有 Hessian、Kryo、Protobuf、ProtoStuff，这些都是基于二进制的序列化协议。")]),v._v(" "),_("p",[v._v("像 JSON 和 XML 这种属于文本类序列化方式。虽然可读性比较好，但是性能较差，一般不会选择。")]),v._v(" "),_("h3",{attrs:{id:"为什么不推荐使用-jdk-自带的序列化"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么不推荐使用-jdk-自带的序列化"}},[v._v("#")]),v._v(" 为什么不推荐使用 JDK 自带的序列化？")]),v._v(" "),_("p",[v._v("我们很少或者说几乎不会直接使用 JDK 自带的序列化方式，主要原因有下面这些原因：")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("不支持跨语言调用")]),v._v(" : 如果调用的是其他语言开发的服务的时候就不支持了。")]),v._v(" "),_("li",[_("strong",[v._v("性能差")]),v._v(" ：相比于其他序列化框架性能更低，主要原因是序列化之后的字节数组体积较大，导致传输成本加大。")]),v._v(" "),_("li",[_("strong",[v._v("存在安全问题")]),v._v(" ：序列化和反序列化本身并不存在问题。但当输入的反序列化的数据可被用户控制，那么攻击者即可通过构造恶意输入，让反序列化产生非预期的对象，在此过程中执行构造的任意代码。")])])])}),[],!1,null,null,null);_.default=a.exports}}]);