(window.webpackJsonp=window.webpackJsonp||[]).push([[244],{704:function(e,v,t){"use strict";t.r(v);var s=t(1),_=Object(s.a)({},(function(){var e=this,v=e._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[v("ul",[v("li",[e._v("文件事件处理器（file event handler）")])]),e._v(" "),v("p",[e._v("1、Redis基于Reactor模式开发自己的网络事件处理器：这个处理器被称为文件事件处理器（file event handler）")]),e._v(" "),v("p",[e._v("2、文件事件处理器使用I/O多路复用（multiplexing）程序来同时监听多个套接字，并根据套接字目前执行的任务来为套接字关联不同的事务处理器；")]),e._v(" "),v("p",[e._v("3、当被监听的套接字准备好执行连接应答（accept）、读取（read）、写入（write）、关闭（close）等操作时， 与操作相对应的文件事件就会产生， 这时文件事件处理器就会调用套接字之前关联好的事件处理器来处理这些事件；")]),e._v(" "),v("p",[e._v("4、文件事件处理器以单线程方式运行， 但通过使用 I/O 多路复用程序来监听多个套接字， 文件事件处理器既实现了高性能的网络通信模型， 又可以很好地与 redis 服务器中其他同样以单线程方式运行的模块进行对接， 这保持了 Redis 内部单线程设计的简单性；")]),e._v(" "),v("ul",[v("li",[e._v("Redis线程模型")])]),e._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/b88bf1150cfa4d90b85c8d146ce0d4ef.png",alt:"在这里插入图片描述"}})]),e._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/8b03be9e61df4a51963f0bccbff9b4c3.png",alt:"在这里插入图片描述"}})]),e._v(" "),v("p",[e._v("Redis客户端对服务端的每次调用都经历了发送命令，执行命令，返回结果三个过程。"),v("code",[e._v("其中执行命令阶段，由于Redis是单线程来处理命令的，所有每一条到达服务端的命令不会立刻执行，所有的命令都会进入一个队列中，然后逐个被执行")]),e._v("。并且多个客户端发送的命令的执行顺序是不确定的。但是可以确定的是不会有两条命令被同时执行，不会产生并发问题，这就是Redis的单线程基本模型。")]),e._v(" "),v("ul",[v("li",[e._v("Redis是单线程模型为什么效率还那么高？")])]),e._v(" "),v("p",[e._v("1、纯内存访问：数据放在内存中，内存的响应时间极快，这是Redis每秒万亿级别访问的重要基础；")]),e._v(" "),v("p",[e._v("2、非阻塞IO：Redis采用epoll作为I/O多路复用技术的实现，再加上Redis自身的事件处理模型将epoll中的连接、读写、关闭都转换为了时间，不在IO上浪费过多的时间；")]),e._v(" "),v("p",[e._v("3、单线程避免了线程切换和竞态产生的消耗；")]),e._v(" "),v("p",[e._v("4、Redis采用单线程模型，每条命令执行如果占用大量时间，会造成其他线程阻塞，对于Redis这种高性能服务是致命的，所以Redis是面向高速执行的数据库。")]),e._v(" "),v("ul",[v("li",[e._v("IO多路复用技术")])]),e._v(" "),v("p",[e._v("举个例子，模拟一个tcp服务器处理30个客户socket。")]),e._v(" "),v("p",[e._v("假设你是一个老师，让30个学生解答一道题目，然后检查学生做的是否正确，你有下面几个选择：")]),e._v(" "),v("p",[e._v("第一种选择：按顺序逐个检查，先检查A，然后是B，之后是C、D。。。这中间如果有一个学生卡主，全班都会被耽误。这种模式就好比，你用循环挨个处理socket，根本不具有并发能力。")]),e._v(" "),v("p",[e._v("第二种选择：你创建30个分身，每个分身检查一个学生的答案是否正确。 这种类似于为每一个用户创建一个进程或者线程处理连接。")]),e._v(" "),v("p",[e._v("第三种选择，你站在讲台上等，谁解答完谁举手。这时C、D举手，表示他们解答问题完毕，你下去依次检查C、D的答案，然后继续回到讲台上等。此时E、A又举手，然后去处理E和A。。。 这种就是IO复用模型")]),e._v(" "),v("p",[e._v("（Linux下的select、poll和epoll就是干这个的。将用户socket对应的fd注册进epoll，然后epoll帮你监听哪些socket上有消息到达，这样就避免了大量的无用操作。此时的socket应该采用非阻塞模式。这样，整个过程只在调用select、poll、epoll这些调用的时候才会阻塞，收发客户消息是不会阻塞的，整个进程或者线程就被充分利用起来，这就是事件驱动，所谓的reactor模式。）")]),e._v(" "),v("h3",{attrs:{id:"为什么redis是单线程的但是能够实现高并发"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#为什么redis是单线程的但是能够实现高并发"}},[e._v("#")]),e._v(" 为什么Redis是单线程的但是能够实现高并发？")]),e._v(" "),v("p",[e._v("1）因为Redis的多路复用技术，让单个线程高效的处理多个连接请求（尽量减少网络IO的时间消耗）；")]),e._v(" "),v("p",[e._v("2）Redis采用单线程可以避免添加锁，也可以避免线程频繁的上下文切换；")]),e._v(" "),v("p",[e._v("单线程处理的缺点？\n无法发挥多核CPU的性能，不过可以通过在单机上开多个Redis实例来完善。")]),e._v(" "),v("h3",{attrs:{id:"redis不存在线程安全问题"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#redis不存在线程安全问题"}},[e._v("#")]),e._v(" Redis不存在线程安全问题？")]),e._v(" "),v("p",[e._v("Redis是单线程模型，把任务都封闭到了一个线程中，自然避免了线程安全问题，不过对于需要依赖多个Redis操作的复合操作而言，依然需要锁，而且有可能是分布式锁。")]),e._v(" "),v("h3",{attrs:{id:"什么是i-o多路复用-epoll"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#什么是i-o多路复用-epoll"}},[e._v("#")]),e._v(" 什么是I/O多路复用（Epoll）？")]),e._v(" "),v("p",[e._v("1）网络IO都是通过socket实现，server在某一个端口持续监听，客户端通过socket（IP+Port）与服务器建立连接（ServerSocket.accept），成功建立连接之后，就可以使用Socket中封装的InputStream和OutputStream进行IO交互了。针对每个客户端，server都会创建一个新的线程专门用于处理；")]),e._v(" "),v("p",[e._v("2）默认情况下，网络IO是阻塞模式，即服务器线程在数据到来之前处于【阻塞】状态，等待数据到达，会自动唤醒服务器线程，着手进行处理。阻塞模式下，一个线程只能处理一个流的IO事件；")]),e._v(" "),v("p",[e._v("3）为了提升服务器线程处理效率，有以下三种思路：")]),e._v(" "),v("p",[e._v("（1）非阻塞【忙轮询】：采用死循环的方式轮询每一个流，如果有IO事件就处理，这样可以使得一个线程可以处理多个流，但是效率不高，容易导致CPU空转；")]),e._v(" "),v("p",[e._v("（2）select代理【无差别轮询】：可以观察多个流的IO事件，如果所有流都没有IO事件，则将线程进入阻塞状态，如果有一个或者多个发生IO事件，则唤醒线程去处理。但是还得遍历所有的流，才能找到哪些流需要处理，如果流的个数为N，时间复杂度为O(N)；")]),e._v(" "),v("p",[e._v("（3）Epoll代理：Select代理有一个缺点，线程在被唤醒后轮询所有的Stream，还是存在无效操作。Epoll会哪个流发生了怎么样的IO时间通知处理线程，因此对这些流的操作都是有意义的，复杂度降低到了O(1)。")])])}),[],!1,null,null,null);v.default=_.exports}}]);