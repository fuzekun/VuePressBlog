(window.webpackJsonp=window.webpackJsonp||[]).push([[88],{547:function(v,_,t){"use strict";t.r(_);var a=t(1),s=Object(a.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"jvm内存溢出发生在什么地方"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm内存溢出发生在什么地方"}},[v._v("#")]),v._v(" JVM内存溢出发生在什么地方")]),v._v(" "),_("p",[v._v("1、Java堆溢出")]),v._v(" "),_("p",[v._v("Java堆用于存储对象的实例，如果不停的创建对象，并且保证GC Roots到对象之间有可达路径来避免垃圾回收机制清除这些对象，那么对象数量达到最大堆的容量限制之后就会产生内存溢出异常")]),v._v(" "),_("p",[v._v("2、虚拟机栈和本地方法栈溢出")]),v._v(" "),_("p",[v._v("调用方法的时候，会在栈中入栈一个栈帧，如果当前栈的容量不足，就会发生栈溢出")]),v._v(" "),_("p",[v._v("StackOverFlowError")]),v._v(" "),_("p",[v._v("递归调用方法，使方法不断压入栈中，却不出栈；")]),v._v(" "),_("p",[v._v("或者一个方法中的局部变量很多或是很大，导致一个栈帧很大，这两种都会导致栈溢出。")]),v._v(" "),_("p",[v._v("3、运行时常量池溢出")]),v._v(" "),_("p",[v._v("这里存储的是一些常量，字面量。如果运行时常量池内存不足，就会发生内存溢出。")]),v._v(" "),_("p",[v._v("JDK1.7开始，运行时常量池也移动到了堆中，所以如果堆的内存不足，也会导致运行时常量池内存溢出。")]),v._v(" "),_("p",[v._v("4、方法区溢出")]),v._v(" "),_("p",[v._v("方法区是用来存放class的相关信息的，如类名、访问修饰符、字段描述、方法描述等。")]),v._v(" "),_("p",[v._v("对这些区域的测试，基本思想是运行时产生大量的类去填满方法区，直到内存溢出、\n这里使用CGLIB创建大量的代理类。")])])}),[],!1,null,null,null);_.default=s.exports}}]);