(window.webpackJsonp=window.webpackJsonp||[]).push([[82],{544:function(v,_,a){"use strict";a.r(_);var t=a(1),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"jvm的基本介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm的基本介绍"}},[v._v("#")]),v._v(" JVM的基本介绍")]),v._v(" "),_("p",[v._v("JVM 是 Java Virtual Machine 的缩写，它是一个虚构出来的计算机，一种规范。通过在实际的计算机上仿真模拟各类计算机功能实现···")]),v._v(" "),_("p",[v._v("好，其实抛开这么专业的句子不说，就知道JVM其实就类似于一台小电脑运行在windows或者linux这些操作系统环境下即可。它直接和操作系统进行交互，与硬件不直接交互，而操作系统可以帮我们完成和硬件进行交互的工作。")]),v._v(" "),_("h4",{attrs:{id:"java文件是如何被运行的"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java文件是如何被运行的"}},[v._v("#")]),v._v(" Java文件是如何被运行的")]),v._v(" "),_("p",[v._v("比如我们现在写了一个 HelloWorld.java 好了，那这个 HelloWorld.java 抛开所有东西不谈，那是不是就类似于一个文本文件，只是这个文本文件它写的都是英文，而且有一定的缩进而已。")]),v._v(" "),_("p",[v._v("那我们的 "),_("strong",[v._v("JVM")]),v._v(" 是不认识文本文件的，所以它需要一个 "),_("strong",[v._v("编译")]),v._v(" ，让其成为一个它会读二进制文件的 "),_("strong",[v._v("HelloWorld.class")])]),v._v(" "),_("p",[_("strong",[v._v("一、类加载器")])]),v._v(" "),_("p",[v._v("如果 "),_("strong",[v._v("JVM")]),v._v(" 想要执行这个 "),_("strong",[v._v(".class")]),v._v(" 文件，我们需要将其装进一个 "),_("strong",[v._v("类加载器")]),v._v(" 中，它就像一个搬运工一样，会把所有的 "),_("strong",[v._v(".class")]),v._v(" 文件全部搬进JVM里面来。")]),v._v(" "),_("p",[_("strong",[v._v("二、方法区")])]),v._v(" "),_("p",[_("strong",[v._v("方法区")]),v._v(" 是用于存放类似于元数据信息方面的数据的，比如类信息，常量，静态变量，编译后代码···等")]),v._v(" "),_("p",[v._v("类加载器将 .class 文件搬过来就是先丢到这一块上")]),v._v(" "),_("p",[_("strong",[v._v("三、堆")])]),v._v(" "),_("p",[_("strong",[v._v("堆")]),v._v(" 主要放了一些存储的数据，比如对象实例，数组···等，它和方法区都同属于 "),_("strong",[v._v("线程共享区域")]),v._v(" 。也就是说它们都是 "),_("strong",[v._v("线程不安全")]),v._v(" 的")]),v._v(" "),_("p",[_("strong",[v._v("四、栈")])]),v._v(" "),_("p",[_("strong",[v._v("栈")]),v._v(" 这是我们的代码运行空间。我们编写的每一个方法都会放到 "),_("strong",[v._v("栈")]),v._v(" 里面运行。")]),v._v(" "),_("p",[v._v("我们会听说过 本地方法栈 或者 本地方法接口 这两个名词，不过我们基本不会涉及这两块的内容，它俩底层是使用C来进行工作的，和Java没有太大的关系")]),v._v(" "),_("p",[_("strong",[v._v("五、程序计数器")])]),v._v(" "),_("p",[v._v("主要就是完成一个加载工作，类似于一个指针一样的，指向下一行我们需要执行的代码。和栈一样，都是 "),_("strong",[v._v("线程独享")]),v._v(" 的，就是说每一个线程都会有自己对应的一块区域而不会存在并发和多线程的问题。")]),v._v(" "),_("p",[v._v("总结:")]),v._v(" "),_("p",[v._v("Java文件经过编译后变成 .class 字节码文件")]),v._v(" "),_("p",[v._v("字节码文件通过类加载器被搬运到 JVM 虚拟机中")]),v._v(" "),_("p",[v._v("虚拟机主要的5大块：方法区，堆都为线程共享区域，有线程安全问题，栈和本地方法栈和计数器都是独享区域，不存在线程安全问题，而 JVM 的调优主要就是围绕堆，栈两大块进行")]),v._v(" "),_("h4",{attrs:{id:"简单例子"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#简单例子"}},[v._v("#")]),v._v(" 简单例子")]),v._v(" "),_("p",[v._v("执行main方法的步骤如下:")]),v._v(" "),_("ol",[_("li",[v._v("编译好 App.java 后得到 App.class 后，执行 App.class，系统会启动一个 JVM 进程，从 classpath 路径中找到一个名为 App.class 的二进制文件，将 App 的类信息加载到运行时数据区的方法区内，这个过程叫做 App 类的加载")]),v._v(" "),_("li",[v._v("JVM 找到 App 的主程序入口，执行main方法")]),v._v(" "),_("li",[v._v('这个main中的第一条语句为 Student student = new Student("tellUrDream") ，就是让 JVM 创建一个Student对象，但是这个时候方法区中是没有 Student 类的信息的，所以 JVM 马上加载 Student 类，把 Student 类的信息放到方法区中')]),v._v(" "),_("li",[v._v("加载完 Student 类后，JVM 在堆中为一个新的 Student 实例分配内存，然后调用构造函数初始化 Student 实例，这个 Student 实例持有 "),_("strong",[v._v("指向方法区中的 Student 类的类型信息")]),v._v(" 的引用")]),v._v(" "),_("li",[v._v("执行student.sayName();时，JVM 根据 student 的引用找到 student 对象，然后根据 student 对象持有的引用定位到方法区中 student 类的类型信息的方法表，获得 sayName() 的字节码地址。")]),v._v(" "),_("li",[v._v("执行sayName()")])]),v._v(" "),_("p",[v._v("其实也不用管太多，只需要知道对象实例初始化时会去方法区中找类信息，完成后再到栈那里去运行方法。找方法就在方法表中找")]),v._v(" "),_("h3",{attrs:{id:"二、类加载器的介绍"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#二、类加载器的介绍"}},[v._v("#")]),v._v(" 二、类加载器的介绍")]),v._v(" "),_("p",[v._v("之前也提到了它是负责加载.class文件的，它们在文件开头会有特定的文件标示，将class文件字节码内容加载到内存中，并将这些内容转换成方法区中的运行时数据结构，并且ClassLoader只负责class文件的加载，而是否能够运行则由 Execution Engine 来决定")]),v._v(" "),_("h4",{attrs:{id:"类加载器的流程"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器的流程"}},[v._v("#")]),v._v(" 类加载器的流程")]),v._v(" "),_("p",[v._v("从类被加载到虚拟机内存中开始，到释放内存总共有7个步骤：加载，验证，准备，解析，初始化，使用，卸载。其中"),_("strong",[v._v("验证，准备，解析三个部分统称为连接")])]),v._v(" "),_("p",[_("strong",[v._v("加载")])]),v._v(" "),_("ol",[_("li",[v._v("将class文件加载到内存")]),v._v(" "),_("li",[v._v("将静态数据结构转化成方法区中运行时的数据结构")]),v._v(" "),_("li",[v._v("在堆中生成一个代表这个类的 java.lang.Class对象作为数据访问的入口")])]),v._v(" "),_("p",[_("strong",[v._v("链接")])]),v._v(" "),_("p",[v._v("1、验证：确保加载的类符合 JVM 规范和安全，保证被校验类的方法在运行时不会做出危害虚拟机的事件，其实就是一个安全检查")]),v._v(" "),_("p",[v._v("2、准备：为static变量在方法区中分配内存空间，设置变量的初始值，例如 static int a = 3 （注意：准备阶段只设置类中的静态变量（方法区中），不包括实例变量（堆内存中），实例变量是对象初始化时赋值的）")]),v._v(" "),_("p",[v._v("3、解析：虚拟机将常量池内的符号引用替换为直接引用的过程（符号引用比如我现在import java.util.ArrayList这就算符号引用，直接引用就是指针或者对象地址，注意引用对象一定是在内存进行）")]),v._v(" "),_("p",[_("strong",[v._v("初始化")])]),v._v(" "),_("p",[v._v("由于执行顺序缘故，初始化阶段类变量如果在静态代码块中又进行了更改，会覆盖类变量的显式初始化，最终值会为静态代码块中的赋值。")]),v._v(" "),_("p",[_("strong",[v._v("卸载")])]),v._v(" "),_("p",[v._v("GC将无用对象从内存中卸载")]),v._v(" "),_("h4",{attrs:{id:"类加载器的加载顺序"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#类加载器的加载顺序"}},[v._v("#")]),v._v(" 类加载器的加载顺序")]),v._v(" "),_("p",[v._v("加载一个Class类的顺序也是有优先级的，类加载器从最底层开始往上的顺序是这样的")]),v._v(" "),_("ol",[_("li",[v._v("BootStrap ClassLoader：rt.jar")]),v._v(" "),_("li",[v._v("Extension ClassLoader: 加载扩展的jar包")]),v._v(" "),_("li",[v._v("App ClassLoader：指定的classpath下面的jar包")]),v._v(" "),_("li",[v._v("Custom ClassLoader：自定义的类加载器")])]),v._v(" "),_("h4",{attrs:{id:"双亲委派机制"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#双亲委派机制"}},[v._v("#")]),v._v(" 双亲委派机制")]),v._v(" "),_("p",[v._v("当一个类收到了加载请求时，它是不会先自己去尝试加载的，而是委派给父类去完成，比如我现在要 new 一个 Person，这个 Person 是我们自定义的类，如果我们要加载它，就会先委派 App ClassLoader ，只有当父类加载器都反馈自己无法完成这个请求（也就是父类加载器都没有找到加载所需的 Class）时，子类加载器才会自行尝试加载。")]),v._v(" "),_("p",[v._v("这样做的好处是，加载位于 rt.jar 包中的类时不管是哪个加载器加载，最终都会委托到 BootStrap ClassLoader 进行加载，这样保证了使用不同的类加载器得到的都是同一个结果。")]),v._v(" "),_("p",[v._v("其实这个也是一个隔离的作用，避免了我们的代码影响了 JDK 的代码.")]),v._v(" "),_("h3",{attrs:{id:"运行时数据区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#运行时数据区"}},[v._v("#")]),v._v(" 运行时数据区")]),v._v(" "),_("h4",{attrs:{id:"本地方法栈和程序计数器"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#本地方法栈和程序计数器"}},[v._v("#")]),v._v(" 本地方法栈和程序计数器")]),v._v(" "),_("p",[v._v("比如说我们现在点开Thread类的源码，会看到它的start0方法带有一个native关键字修饰，而且不存在方法体，这种用native修饰的方法就是本地方法，这是使用C来实现的，然后一般这些方法都会放到一个叫做本地方法栈的区域。")]),v._v(" "),_("p",[v._v("程序计数器其实就是一个指针，它指向了我们程序中下一句需要执行的指令，它也是内存区域中唯一一个不会出现OutOfMemoryError的区域，而且占用内存空间小到基本可以忽略不计。这个内存仅代表当前线程所执行的字节码的行号指示器，字节码解析器通过改变这个计数器的值选取下一条需要执行的字节码指令。")]),v._v(" "),_("p",[v._v("如果执行的是native方法，那这个指针就不工作了.")]),v._v(" "),_("h4",{attrs:{id:"方法区"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法区"}},[v._v("#")]),v._v(" 方法区")]),v._v(" "),_("p",[v._v("方法区主要的作用是存放类的元数据信息，常量和静态变量···等。当它存储的信息过大时，会在无法满足内存分配时报错。")]),v._v(" "),_("h4",{attrs:{id:"虚拟机栈和虚拟机堆"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#虚拟机栈和虚拟机堆"}},[v._v("#")]),v._v(" 虚拟机栈和虚拟机堆")]),v._v(" "),_("p",[v._v("一句话便是：栈管运行，堆管存储。则虚拟机栈负责运行代码，而虚拟机堆负责存储数据。")]),v._v(" "),_("p",[_("strong",[v._v("虚拟机栈的概念")])]),v._v(" "),_("p",[v._v("它是Java方法执行的内存模型。里面会对局部变量，动态链表，方法出口，栈的操作（入栈和出栈）进行存储，且线程独享。同时如果我们听到局部变量表，那也是在说虚拟机栈")]),v._v(" "),_("p",[_("strong",[v._v("虚拟机栈存在的异常")])]),v._v(" "),_("p",[v._v("如果线程请求的栈的深度大于虚拟机栈的最大深度，就会报 "),_("strong",[v._v("StackOverflowError")]),v._v("  （这种错误经常出现在递归中） . Java虚拟机也可以动态扩展，但随着扩展会不断地申请内存，当无法申请足够内存时就会报错 "),_("strong",[v._v("OutOfMemoryError")])]),v._v(" "),_("p",[_("strong",[v._v("虚拟机栈的生命周期")])]),v._v(" "),_("p",[v._v("对于栈来说，不存在垃圾回收。只要程序运行结束，栈的空间自然就会释放了。栈的生命周期和所处的线程是一致的。")]),v._v(" "),_("p",[v._v("这里补充一句：8种基本类型的变量+对象的引用变量+实例方法都是在栈里面分配内存")]),v._v(" "),_("p",[_("strong",[v._v("虚拟机栈的执行")])]),v._v(" "),_("p",[v._v("我们经常说的栈帧数据，说白了在JVM中叫栈帧，放到Java中其实就是方法，它也是存放在栈中的。")]),v._v(" "),_("p",[v._v("栈中的数据都是以栈帧的格式存在，它是一个关于方法和运行期数据的数据集。比如我们执行一个方法a，就会对应产生一个栈帧A1，然后A1会被压入栈中。同理方法b会有一个B1，方法c会有一个C1，等到这个线程执行完毕后，栈会先弹出C1，后B1,A1。它是一个先进后出，后进先出原则。")]),v._v(" "),_("p",[_("strong",[v._v("局部变量的复用")])]),v._v(" "),_("p",[v._v("局部变量表用于存放方法参数和方法内部所定义的局部变量。它的容量是以Slot为最小单位，一个slot可以存放32位以内的数据类型。")]),v._v(" "),_("p",[v._v("虚拟机通过索引定位的方式使用局部变量表，范围为[0,局部变量表的slot的数量]。方法中的参数就会按一定顺序排列在这个局部变量表中，至于怎么排的我们可以先不关心。而为了节省栈帧空间，这些slot是可以复用的，当方法执行位置超过了某个变量，那么这个变量的slot可以被其它变量复用。当然如果需要复用，那我们的垃圾回收自然就不会去动这些内存。")]),v._v(" "),_("p",[_("strong",[v._v("虚拟机堆的概念")])]),v._v(" "),_("p",[v._v("JVM内存会划分为堆内存和非堆内存，堆内存中也会划分为"),_("strong",[v._v("年轻代")]),v._v("和"),_("strong",[v._v("老年代")]),v._v("，而非堆内存则为"),_("strong",[v._v("永久代")]),v._v("。年轻代又会分为"),_("strong",[v._v("Eden")]),v._v("和"),_("strong",[v._v("Survivor")]),v._v("区。Survivor也会分为"),_("strong",[v._v("FromPlace")]),v._v("和"),_("strong",[v._v("ToPlace")]),v._v("，toPlace的survivor区域是空的。Eden，FromPlace和ToPlace的默认占比为 "),_("strong",[v._v("8:1:1")]),v._v("。当然这个东西其实也可以通过一个 -XX:+UsePSAdaptiveSurvivorSizePolicy 参数来根据生成对象的速率动态调整")]),v._v(" "),_("p",[v._v("堆内存中存放的是对象，垃圾收集就是收集这些对象然后交给GC算法进行回收。非堆内存其实我们已经说过了，就是方法区。在1.8中已经移除永久代，替代品是一个元空间(MetaSpace)，最大区别是metaSpace是不存在于JVM中的，它使用的是本地内存。并有两个参数")]),v._v(" "),_("div",{staticClass:"language- line-numbers-mode"},[_("pre",{pre:!0,attrs:{class:"language-text"}},[_("code",[v._v("MetaspaceSize：初始化元空间大小，控制发生GC\nMaxMetaspaceSize：限制元空间大小上限，防止占用过多物理内存。\n")])]),v._v(" "),_("div",{staticClass:"line-numbers-wrapper"},[_("span",{staticClass:"line-number"},[v._v("1")]),_("br"),_("span",{staticClass:"line-number"},[v._v("2")]),_("br")])]),_("p",[v._v("移除的原因可以大致了解一下：融合HotSpot JVM和JRockit VM而做出的改变，因为JRockit是没有永久代的，不过这也间接性地解决了永久代的OOM问题。")]),v._v(" "),_("p",[_("strong",[v._v("Eden年轻代的介绍")])]),v._v(" "),_("p",[v._v("当我们new一个对象后，会先放到Eden划分出来的一块作为存储空间的内存，但是我们知道对堆内存是线程共享的，所以有可能会出现两个对象共用一个内存的情况。这里JVM的处理是为每个线程都预先申请好一块连续的内存空间并规定了对象存放的位置，而如果空间不足会再申请多块内存空间。这个操作我们会称作TLAB，有兴趣可以了解一下。")]),v._v(" "),_("p",[v._v("当Eden空间满了之后，会触发一个叫做Minor GC（就是一个发生在年轻代的GC）的操作，存活下来的对象移动到Survivor0区。Survivor0区满后触发 Minor GC，就会将存活对象移动到Survivor1区，此时还会把from和to两个指针交换，这样保证了一段时间内总有一个survivor区为空且to所指向的survivor区为空。经过多次的 Minor GC后仍然存活的对象（"),_("strong",[v._v("这里的存活判断是15次，对应到虚拟机参数为 -XX:MaxTenuringThreshold 。为什么是15，因为HotSpot会在对象投中的标记字段里记录年龄，分配到的空间仅有4位，所以最多只能记录到15")]),v._v("）会移动到老年代。老年代是存储长期存活的对象的，占满时就会触发我们最常听说的Full GC，期间会停止所有线程等待GC的完成。所以对于响应要求高的应用应该尽量去减少发生Full GC从而避免响应超时的问题。")]),v._v(" "),_("p",[v._v("而且当老年区执行了full gc之后仍然无法进行对象保存的操作，就会产生OOM，这时候就是虚拟机中的堆内存不足，原因可能会是堆内存设置的大小过小，这个可以通过参数-Xms、-Xmx来调整。也可能是代码中创建的对象大且多，而且它们一直在被引用从而长时间垃圾收集无法收集它们。")]),v._v(" "),_("p",[_("strong",[v._v("如何判断一个对象需要被干掉")])]),v._v(" "),_("p",[v._v("图中程序计数器、虚拟机栈、本地方法栈，3个区域随着线程的生存而生存的。内存分配和回收都是确定的。随着线程的结束内存自然就被回收了，因此不需要考虑垃圾回收的问题。而Java堆和方法区则不一样，各线程共享，内存的分配和回收都是动态的。因此垃圾收集器所关注的都是堆和方法这部分内存。")]),v._v(" "),_("p",[v._v("在进行回收前就要判断哪些对象还存活，哪些已经死去。下面介绍两个基础的计算方法")]),v._v(" "),_("p",[v._v("1.引用计数器计算：给对象添加一个引用计数器，每次引用这个对象时计数器加一，引用失效时减一，计数器等于0时就是不会再次使用的。不过这个方法有一种情况就是出现对象的循环引用时GC没法回收。")]),v._v(" "),_("p",[v._v("2.可达性分析计算：这是一种类似于二叉树的实现，将一系列的GC ROOTS作为起始的存活对象集，从这个节点往下搜索，搜索所走过的路径成为引用链，把能被该集合引用到的对象加入到集合中。搜索当一个对象到GC Roots没有使用任何引用链时，则说明该对象是不可用的。主流的商用程序语言，例如Java，C#等都是靠这招去判定对象是否存活的。")]),v._v(" "),_("p",[v._v("在Java语言汇总能作为GC Roots的对象分为以下几种：")]),v._v(" "),_("ol",[_("li",[v._v("虚拟机栈（栈帧中的本地方法表）中引用的对象（局部变量）")]),v._v(" "),_("li",[v._v("方法区中静态变量所引用的对象（静态变量）")]),v._v(" "),_("li",[v._v("方法区中常量引用的对象")]),v._v(" "),_("li",[v._v("本地方法栈（即native修饰的方法）中JNI引用的对象（JNI是Java虚拟机调用对应的C函数的方式，通过JNI函数也可以创建新的Java对象。且JNI对于对象的局部引用或者全局引用都会把它们指向的对象都标记为不可回收）")]),v._v(" "),_("li",[v._v("已启动的且未终止的Java线程")])]),v._v(" "),_("p",[_("strong",[v._v("如何宣告一个对象的真正死亡")])]),v._v(" "),_("p",[v._v("首先必须要提到的是一个名叫 "),_("strong",[v._v("finalize()")]),v._v(" 的方法")]),v._v(" "),_("p",[v._v("finalize()是Object类的一个方法、一个对象的finalize()方法只会被系统自动调用一次，经过finalize()方法逃脱死亡的对象，第二次不会再调用。")]),v._v(" "),_("p",[v._v("补充一句：并不提倡在程序中调用finalize()来进行自救。建议忘掉Java程序中该方法的存在。因为它执行的时间不确定，甚至是否被执行也不确定（Java程序的不正常退出），而且运行代价高昂，无法保证各个对象的调用顺序（甚至有不同线程中调用）")]),v._v(" "),_("p",[v._v("判断一个对象的死亡至少需要两次标记")]),v._v(" "),_("ol",[_("li",[v._v("如果对象进行可达性分析之后没发现与GC Roots相连的引用链，那它将会第一次标记并且进行一次筛选。判断的条件是决定这个对象是否有必要执行finalize()方法。如果对象有必要执行finalize()方法，则被放入F-Queue队列中。")]),v._v(" "),_("li",[v._v("GC对F-Queue队列中的对象进行二次标记。如果对象在finalize()方法中重新与引用链上的任何一个对象建立了关联，那么二次标记时则会将它移出“即将回收”集合。如果此时对象还没成功逃脱，那么只能被回收了。")])]),v._v(" "),_("h4",{attrs:{id:"垃圾回收算法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#垃圾回收算法"}},[v._v("#")]),v._v(" 垃圾回收算法")]),v._v(" "),_("p",[v._v("常用的有标记清除，复制，标记整理和分代收集算法")]),v._v(" "),_("p",[_("strong",[v._v("标记清除算法")])]),v._v(" "),_("p",[v._v("标记清除算法就是分为“标记”和“清除”两个阶段。标记出所有需要回收的对象，标记结束后统一回收。这个套路很简单，也存在不足，后续的算法都是根据这个基础来加以改进的。")]),v._v(" "),_("p",[v._v("其实它就是把已死亡的对象标记为空闲内存，然后记录在一个空闲列表中，当我们需要new一个对象时，内存管理模块会从空闲列表中寻找空闲的内存来分给新的对象。")]),v._v(" "),_("p",[v._v("不足的方面就是标记和清除的效率比较低下。且这种做法会让内存中的碎片非常多。这个导致了如果我们需要使用到较大的内存块时，无法分配到足够的连续内存。")]),v._v(" "),_("p",[_("strong",[v._v("复制算法")])]),v._v(" "),_("p",[v._v("为了解决效率问题，复制算法就出现了。它将可用内存按容量划分成两等分，每次只使用其中的一块。和survivor一样也是用from和to两个指针这样的玩法。fromPlace存满了，就把存活的对象copy到另一块toPlace上，然后交换指针的内容。这样就解决了碎片的问题。")]),v._v(" "),_("p",[v._v("这个算法的代价就是把内存缩水了，这样堆内存的使用效率就会变得十分低下了")]),v._v(" "),_("p",[v._v("不过它们分配的时候也不是按照1:1这样进行分配的，就类似于Eden和Survivor也不是等价分配是一个道理。")]),v._v(" "),_("p",[_("strong",[v._v("标记整理算法")])]),v._v(" "),_("p",[v._v("复制算法在对象存活率高的时候会有一定的效率问题，标记过程仍然与“标记-清除”算法一样，但后续步骤不是直接对可回收对象进行清理，而是让所有存活的对象都向一端移动，然后直接清理掉边界以外的内存")]),v._v(" "),_("p",[_("strong",[v._v("分代收集算法")])]),v._v(" "),_("p",[v._v("这种算法并没有什么新的思想，只是根据对象存活周期的不同将内存划分为几块。一般是把Java堆分为新生代和老年代，这样就可以根据各个年代的特点采用最适当的收集算法。在新生代中，每次垃圾收集时都发现有大批对象死去，只有少量存活，那就选用复制算法，只需要付出少量存活对象的复制成本就可以完成收集。而老年代中因为对象存活率高、没有额外空间对它进行分配担保，就必须使用“标记-清理”或者“标记-整理”算法来进行回收。")]),v._v(" "),_("p",[v._v("到jdk8为止，默认的垃圾收集器是Parallel Scavenge 和 Parallel Old")]),v._v(" "),_("p",[v._v("从jdk9开始，G1收集器成为默认的垃圾收集器 目前来看，G1回收器停顿时间最短而且没有明显缺点，非常适合Web应用。在jdk8中测试Web应用，堆内存6G，新生代4.5G的情况下，Parallel Scavenge 回收新生代停顿长达1.5秒。G1回收器回收同样大小的新生代只停顿0.2秒。")]),v._v(" "),_("h3",{attrs:{id:"关于jvm调优的一些方面"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#关于jvm调优的一些方面"}},[v._v("#")]),v._v(" 关于JVM调优的一些方面")]),v._v(" "),_("p",[v._v("根据刚刚涉及的jvm的知识点，我们可以尝试对JVM进行调优，主要就是堆内存那块")]),v._v(" "),_("p",[v._v("所有线程共享数据区大小=新生代大小 + 年老代大小 + 持久代大小。持久代一般固定大小为64m。所以java堆中增大年轻代后，将会减小年老代大小（因为老年代的清理是使用fullgc，所以老年代过小的话反而是会增多fullgc的）。此值对系统性能影响较大，Sun官方推荐配置为java堆的3/8。")]),v._v(" "),_("h4",{attrs:{id:"调整最大堆内存和最小堆内存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#调整最大堆内存和最小堆内存"}},[v._v("#")]),v._v(" 调整最大堆内存和最小堆内存")]),v._v(" "),_("p",[v._v("-Xmx –Xms：指定java堆最大值（默认值是物理内存的1/4(<1GB)）和初始java堆最小值（默认值是物理内存的1/64(<1GB))")]),v._v(" "),_("p",[v._v("默认(MinHeapFreeRatio参数可以调整)空余堆内存小于40%时，JVM就会增大堆直到-Xmx的最大限制.，默认(MaxHeapFreeRatio参数可以调整)空余堆内存大于70%时，JVM会减少堆直到 -Xms的最小限制。简单点来说，你不停地往堆内存里面丢数据，等它剩余大小小于40%了，JVM就会动态申请内存空间不过会小于-Xmx，如果剩余大小大于70%，又会动态缩小不过不会小于–Xms。就这么简单")]),v._v(" "),_("p",[v._v("开发过程中，通常会将 -Xms 与 -Xmx两个参数配置成相同的值，其目的是为了能够在java垃圾回收机制清理完堆区后不需要重新分隔计算堆区的大小而浪费资源。")]),v._v(" "),_("p",[_("strong",[v._v("调整新生代和老年代的比值")])]),v._v(" "),_("p",[_("strong",[v._v("调整Survivor区和Eden区的比值")])]),v._v(" "),_("p",[_("strong",[v._v("设置年轻代和老年代的大小")])])])}),[],!1,null,null,null);_.default=s.exports}}]);