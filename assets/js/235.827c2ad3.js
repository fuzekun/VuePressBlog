(window.webpackJsonp=window.webpackJsonp||[]).push([[235],{697:function(r,e,a){"use strict";a.r(e);var t=a(1),o=Object(t.a)({},(function(){var r=this,e=r._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":r.$parent.slotKey}},[e("h3",{attrs:{id:"知道leader选举的设计和策略kafka的高可用设计-具体选举的过程如何"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#知道leader选举的设计和策略kafka的高可用设计-具体选举的过程如何"}},[r._v("#")]),r._v(" 知道leader选举的设计和策略kafka的高可用设计，具体选举的过程如何？")]),r._v(" "),e("p",[r._v("最简单最直观的方案是，leader在zk上创建一个临时节点，所有Follower对此节点注册监听，当leader宕机时，此时ISR里的所有Follower都尝试创建该节点，而创建成功者（Zookeeper保证只有一个能创建成功）即是新的Leader，其它Replica即为Follower。")]),r._v(" "),e("p",[r._v("实际上的实现思路也是这样，只是优化了下，多了个代理控制管理类（controller）。**引入的原因是，当kafka集群业务很多，partition达到成千上万时，当broker宕机时，造成集群内大量的调整，会造成大量Watch事件被触发，Zookeeper负载会过重。**zk是不适合大量写操作的。")]),r._v(" "),e("ul",[e("li",[e("p",[r._v("增加删除topic")])]),r._v(" "),e("li",[e("p",[r._v("更新分区副本数量")])]),r._v(" "),e("li",[e("p",[r._v("选举分区leader")])]),r._v(" "),e("li",[e("p",[r._v("集群broker增加和宕机后的调整")])]),r._v(" "),e("li",[e("p",[r._v("当然还有自身的选举controller leader功能controller的功能被写的很重很复杂，代码也很乱，社区都不愿修改他的bug，有准备重构这个功能类。")])])]),r._v(" "),e("p",[r._v("contoller，zk，其他broker交互流程图。")]),r._v(" "),e("p",[r._v("这些功能都是controller通过监听Zookeeper间接节点出发，然后controller再跟其他的broker具体的去交互实现的（rpc的方式）。这种方式"),e("code",[r._v("makes the election process far cheaper and faster for a large number of partitions")])]),r._v(" "),e("ul",[e("li",[r._v("controller的内部设计：")])]),r._v(" "),e("p",[r._v("当前controller启动时会为集群中所有broker创建一个各自的连接。假设你的集群中有100台broker，那么controller启动时会创建100个Socket连接(也包括与它自己的连接！)。具体的类NetworkClient类，底层就是Java NIO reactor模型)。Controller会为每个连接都创建一个对应的请求发送线程（RequestSendThread）。")]),r._v(" "),e("p",[r._v("controller实现如上功能，要先熟悉kafka下zk上的数据存储结构：")]),r._v(" "),e("div",{staticClass:"language-java line-numbers-mode"},[e("pre",{pre:!0,attrs:{class:"language-java"}},[e("code",[r._v("brokers列表：ls "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("brokers"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("ids\n某个broker信息：get "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("brokers"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("ids"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[r._v("0")]),r._v("\ntopic信息：get "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("brokers"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("topics"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("kafka10"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("-")]),r._v("topic"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[r._v("20170924")]),r._v("\npartition信息：get "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("brokers"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("topics"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("kafka10"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("-")]),r._v("topic"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("-")]),e("span",{pre:!0,attrs:{class:"token number"}},[r._v("20170924")]),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("partitions"),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),e("span",{pre:!0,attrs:{class:"token number"}},[r._v("0")]),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("state\ncontroller中心节点变更次数：get "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("controller_epoch\nconrtoller leader信息：get "),e("span",{pre:!0,attrs:{class:"token operator"}},[r._v("/")]),r._v("controller\n\nbroker机器id\n\n某个broker信息\n\ntopic信息\n\npartition信息\n\nconrtoller leader信息\n")])]),r._v(" "),e("div",{staticClass:"line-numbers-wrapper"},[e("span",{staticClass:"line-number"},[r._v("1")]),e("br"),e("span",{staticClass:"line-number"},[r._v("2")]),e("br"),e("span",{staticClass:"line-number"},[r._v("3")]),e("br"),e("span",{staticClass:"line-number"},[r._v("4")]),e("br"),e("span",{staticClass:"line-number"},[r._v("5")]),e("br"),e("span",{staticClass:"line-number"},[r._v("6")]),e("br"),e("span",{staticClass:"line-number"},[r._v("7")]),e("br"),e("span",{staticClass:"line-number"},[r._v("8")]),e("br"),e("span",{staticClass:"line-number"},[r._v("9")]),e("br"),e("span",{staticClass:"line-number"},[r._v("10")]),e("br"),e("span",{staticClass:"line-number"},[r._v("11")]),e("br"),e("span",{staticClass:"line-number"},[r._v("12")]),e("br"),e("span",{staticClass:"line-number"},[r._v("13")]),e("br"),e("span",{staticClass:"line-number"},[r._v("14")]),e("br"),e("span",{staticClass:"line-number"},[r._v("15")]),e("br"),e("span",{staticClass:"line-number"},[r._v("16")]),e("br")])]),e("ul",[e("li",[r._v("partition的leader平衡工具的引入")])]),r._v(" "),e("p",[r._v("为了能让partition和replica均匀的分布在broker上，防止一台机器负载较高。有如下分配算法：")]),r._v(" "),e("p",[r._v("将所有N Broker和待分配的i个Partition排序.")]),r._v(" "),e("p",[r._v("将第i个Partition分配到第(i mod n)个Broker上.")]),r._v(" "),e("p",[r._v("将第i个Partition的第j个副本分配到第((i + j) mod n)个Broker上")]),r._v(" "),e("p",[r._v("topic初始创建后，就会符合上述分配。")]),r._v(" "),e("p",[r._v("但是在集群leader又宕机后，此机器的所有partition的leader都会变化，当原来宕机的机器恢复后，加入到集群变成了follower。此时partition的leader就没有均匀的分布。")]),r._v(" "),e("p",[r._v("kafka提供配置参数，去自动触发均衡操作。也可以手动使用脚本触发。")]),r._v(" "),e("p",[r._v("举个例子，比如5个broker，10个分区，3个副本")]),r._v(" "),e("p",[r._v("partition和replica在broker上的分配例子")]),r._v(" "),e("p",[r._v("在新建topic的时，kafka集群按照上述方法去创建分配，leader是均匀分布的，但是时间久了，当某台机器宕机后，follower会变成leader，之前的leader在机器restart之后，赶上了进度，加入了ISR列表，此时变成了fowller，不在提供读写能力。这个时候就会存在leader分配不均的问题")]),r._v(" "),e("p",[r._v("kafka提供工具"),e("code",[r._v("kafka-preferred-replica-election.sh")]),r._v("去均衡partition的leader")]),r._v(" "),e("p",[r._v("实现思路是：")]),r._v(" "),e("p",[r._v("引入"),e("code",[r._v("preferred-replica")]),r._v("概念，ISR列表里，第一个replica就是preferred-replica，第一个加入列表的肯定是当前机器（就是当前的broker id）。broker宕机后变为follower，但是ISR的preferred-replica不会变，执行kafka-preferred-replica-election.sh脚本就是把****preferred-replica选为leader的过程。")]),r._v(" "),e("p",[r._v("上边是手动触发，也可以配置参数auto.leader.rebalance.enable=true，kafka监控到不均衡度达到多少时自动作均衡")]),r._v(" "),e("p",[r._v("新建一个topic kafka10-topic-20170928，partition的leader均匀分布")]),r._v(" "),e("p",[r._v("初始创建topic后分区信息")]),r._v(" "),e("p",[r._v("模拟broker0宕机后，controller由原来的0变成了2")]),r._v(" "),e("p",[r._v("broker0宕机后controller变更")]),r._v(" "),e("p",[r._v("原来partition1的leader是0，所以需要重新选举，从leader_epoch数字也能看出来，leader变成了2。同时三个partition的isr列表都少了broker0")]),r._v(" "),e("p",[r._v("broker0宕机后，分区状态信息")]),r._v(" "),e("p",[r._v("这个时候，重启broker0，预计下")]),r._v(" "),e("p",[r._v("1、由于broker0上的follower会赶上进度，三个partition的isr列表肯定会吧0都加上。")]),r._v(" "),e("p",[r._v("2、broker0加入集群后，partition1在broker0上的副本会是folllower，leader应该还是2")]),r._v(" "),e("p",[r._v("restart broker0后分区状态信息")]),r._v(" "),e("p",[r._v("嗯这个时候，能看出来leader是分配不均匀的。两个leader在broker2上，一个在broker1上。然后试验下自动均衡脚本工具：")]),r._v(" "),e("p",[e("code",[r._v("sh kafka-preferred-replica-election.sh --zookeeper localhost:2181")])]),r._v(" "),e("p",[r._v("执行kafka-preferred-replica-election.sh后")]),r._v(" "),e("p",[r._v("ok，执行后，partition的leader变回broker0（topic最初创建的时候）。分区的选举次数leader_epoch变量也+1")]),r._v(" "),e("p",[r._v("如果嫌kafka的replica分配不好，可以使用提供的工具kafka-reassign-partitions.sh")])])}),[],!1,null,null,null);e.default=o.exports}}]);