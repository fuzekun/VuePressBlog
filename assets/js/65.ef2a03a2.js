(window.webpackJsonp=window.webpackJsonp||[]).push([[65],{524:function(a,t,_){"use strict";_.r(t);var v=_(1),e=Object(v.a)({},(function(){var a=this,t=a._self._c;return t("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[t("h3",{attrs:{id:"一、什么是事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#一、什么是事务"}},[a._v("#")]),a._v(" 一、什么是事务？")]),a._v(" "),t("p",[a._v("事务（transaction），一般是指要做的或者所做的事情。在计算机术语中是指访问并可能更新数据库中各种数据项的一个程序执行单元（Unit）。事务通常由高级数据库操作语言或编程语言（如SQL、C++或Java）来书写。事务由事务开始（begin transaction）和事务结束（end transaction）之间执行的全体操作组成。")]),a._v(" "),t("h3",{attrs:{id:"二、事务概述"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#二、事务概述"}},[a._v("#")]),a._v(" 二、事务概述")]),a._v(" "),t("h4",{attrs:{id:"_1、事务的特性-acid"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_1、事务的特性-acid"}},[a._v("#")]),a._v(" 1、事务的特性（ACID）")]),a._v(" "),t("ul",[t("li",[t("p",[a._v("事务的原子性(Atomic）：即一个事务要么全部完成，要么都不完成，在Java中执行事务过程如果出现异常，使事务没法继续进行下去，此时会让事务回滚（Rollback）进而来保证事务的原子性；")])]),a._v(" "),t("li",[t("p",[a._v("事务一致性（Consistency）：比如在银行转账的案例中，A给B转账，不会A转完账后，B却没有受到，这就破坏了事务的一致性；")])]),a._v(" "),t("li",[t("p",[a._v("隔离性（Isolation）：指一个事务的执行不会被其他事务所干扰，即一个事务内部的操作及使用的数据对并发的其他事务是隔离的，并发的事务之间不会相互干扰；比如A在从一张银行中取钱的时候，B不能向该卡里存钱；")])]),a._v(" "),t("li",[t("p",[a._v("持久性（Durability）：指一个事务一旦提交，他的数据库中的数据的改变是永久性的。提交后的其他操作或故障不会对其有任何影响。")])])]),a._v(" "),t("p",[a._v("第一类丢失更新（回滚丢失）：")]),a._v(" "),t("p",[a._v("A事务撤销时，把已经移交的B事务的更新数据覆盖了。")]),a._v(" "),t("p",[a._v("第二类丢失更新（覆盖丢失/两次更新的问题）：")]),a._v(" "),t("p",[a._v("A事务覆盖B事务已经提交的数据，造成B事务所做的操作丢失。")]),a._v(" "),t("h4",{attrs:{id:"_2、脏读、幻读、不可重复读"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_2、脏读、幻读、不可重复读"}},[a._v("#")]),a._v(" 2、脏读、幻读、不可重复读")]),a._v(" "),t("p",[t("code",[a._v("脏读")]),a._v("：一个事务读取到另一个事务未提交的数据，比如A在读取银行卡的余额时，B在向银行卡中转账，但是由于转账中出现了问题，数据其实并未提交，但是A在读取的时候就读到了B未提交的数据；")]),a._v(" "),t("p",[t("code",[a._v("不可重复读")]),a._v("：事务A在读取数据的过程中，事务B对数据进行了多次的修改并提交，这就可能导致A在读取数据时，数据前后不一致；")]),a._v(" "),t("p",[t("code",[a._v("幻读")]),a._v("：事务A在操作过程中进行两次查询，第二次查询的结果包含了第一次查询中未出现的数据，这时因为在两次查询中有另外一个事务B插入了新的数据，这样导致事务A似乎出现了幻觉，幻读大多数出现在当一个事务读取数据时，另一个事务插入或删除数据.")]),a._v(" "),t("h4",{attrs:{id:"_3、事务的隔离级别"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#_3、事务的隔离级别"}},[a._v("#")]),a._v(" 3、事务的隔离级别")]),a._v(" "),t("p",[t("code",[a._v("read-uncommitted")]),a._v("（读未提交）：这种隔离级别最低，会产生脏读、幻读、不可重复读等问题；")]),a._v(" "),t("p",[t("code",[a._v("read-committed")]),a._v("（读已提交）："),t("code",[a._v("一个事务在执行过程中，既可访问其他事务成功提交的数据，又可访问其他事务成功修改的数据")]),a._v("，这样可以避免脏读。"),t("code",[a._v("读取数据的事务允许其他事务继续访问改行数据，但是未提交的写事务将会禁止其他事务访问")]),a._v("。")]),a._v(" "),t("p",[a._v("SQL Server和Oracle的默认隔离级别就是读已提交；")]),a._v(" "),t("p",[t("code",[a._v("repeatable read")]),a._v("（可重复读）：一个事务在执行过程中，"),t("code",[a._v("可以访问其他事务成功提交的新插入的数据，但不可以访问修改的数据。读取数据的事务会禁止写事务（但允许读事务），写事务则禁止任何其他事务")]),a._v("。此隔离级别可以防止脏读和不可重复读；")]),a._v(" "),t("p",[a._v("MySQL默认的就是可重复读的隔离级别；")]),a._v(" "),t("p",[t("code",[a._v("序列化（Serializable）")]),a._v("：提供严格的事务隔离，事务只能一条一条的执行，可以避免出现的所有问题，但是事务不能并发执行，效率很低。")]),a._v(" "),t("p",[a._v("从事务的安全性来说：Serializable>repeatable read>committed-read>uncommitted-read")]),a._v(" "),t("p",[a._v("但是从事务的执行效率来说：uncommitted read > commiitted read > repeatable read > serializable")]),a._v(" "),t("p",[a._v("所以事务的安全级别不是越高越好，而是应该根据需求合理的选择事务的安全级别。")]),a._v(" "),t("h3",{attrs:{id:"spring注解方式管理事务"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring注解方式管理事务"}},[a._v("#")]),a._v(" Spring注解方式管理事务")]),a._v(" "),t("h3",{attrs:{id:"spring声明式的事务管理方式-aop"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#spring声明式的事务管理方式-aop"}},[a._v("#")]),a._v(" Spring声明式的事务管理方式----AOP")])])}),[],!1,null,null,null);t.default=e.exports}}]);