(window.webpackJsonp=window.webpackJsonp||[]).push([[184],{644:function(_,v,t){"use strict";t.r(v);var e=t(1),s=Object(e.a)({},(function(){var _=this,v=_._self._c;return v("ContentSlotsDistributor",{attrs:{"slot-key":_.$parent.slotKey}},[v("h3",{attrs:{id:"一、处理机相关的调度算法的若干准则"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#一、处理机相关的调度算法的若干准则"}},[_._v("#")]),_._v(" 一、处理机相关的调度算法的若干准则")]),_._v(" "),v("p",[_._v("1）面向用户的准则：周转时间（CPU执行用时Ts、周转时间"),v("code",[_._v("T=Ts+Tw")]),_._v("、带权周转时间W=T/Ts）、响应时间快、均衡性、截止时间的保证、优先权准则；")]),_._v(" "),v("p",[_._v("2）面向系统的准则：系统吞吐量高、处理机利用率好、各类资源的平衡利用")]),_._v(" "),v("p",[_._v("3）批处理系统为照顾为数众多的短作业，应采用短作业优先的调度算法；分时系统为保证系统具有合理的响应时间，应采用轮转法进行调度。")]),_._v(" "),v("h3",{attrs:{id:"二、常用调度算法"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#二、常用调度算法"}},[_._v("#")]),_._v(" 二、常用调度算法")]),_._v(" "),v("p",[_._v("1、先来先服务的调度算法（"),v("code",[_._v("FCFS：First Come First Service")]),_._v("）")]),_._v(" "),v("p",[_._v("a. 按照作业提交的顺序，或进程变为就绪状态的先后次序分派CPU；")]),_._v(" "),v("p",[_._v("b. 新作业只是当当前作业或进程执行完或者是阻塞才获得CPU运行；")]),_._v(" "),v("p",[_._v("c. 被唤醒的作业或进程不立即恢复执行，通常是等到当前作业或进程让出CPU。（所以，默认即是非抢占式的）")]),_._v(" "),v("p",[_._v("d. 有利于CPU繁忙型作业，而不利于I/O繁忙的作业（进程）。")]),_._v(" "),v("p",[_._v("2、短作业（进程）优先调度算法"),v("code",[_._v("SJF")]),_._v("（非抢占式）/SPF（抢占）")]),_._v(" "),v("p",[_._v("a. 平均周转时间、平均带权周转时间都有明显的改善。"),v("code",[_._v("SJF/SPF")]),_._v("调度算法能有效降低作业的平均等待时间、提高系统吞吐量；")]),_._v(" "),v("p",[_._v("b. 未考虑作业的紧迫程度，因而不能保证紧迫作业（进程）的及时处理、对长作业不利、作业（进程）的长短含主观因素，不一定能真正做到短作业优先；")]),_._v(" "),v("p",[_._v("3、高优先权优先调度算法"),v("code",[_._v("HPF")])]),_._v(" "),v("p",[_._v("a. 两种方式：非抢占式优先算法、抢占式优先算法（关键点：新作业产生时）")]),_._v(" "),v("p",[_._v("b. 类型：静态优先权：创建进程时确定，整个运行期间保持不变。动态优先权：创建进程时赋予的优先权可随进程的推进或随其等待时间的增加而改变；")]),_._v(" "),v("p",[_._v("c. 高响应比优先调度算法"),v("code",[_._v("HRRN")])]),_._v(" "),v("p",[v("code",[_._v("HRRN")]),_._v("为每个作业引入动态优先权，使作业的优先级随着等待时间的增加而增加以速率a提高；优先权=（等待时间+要求服务时间）/要求服务时间 = 响应时间/要求服务时间")]),_._v(" "),v("p",[_._v("4、基于时间片的轮转调度算法RR")]),_._v(" "),v("p",[_._v("（1）时间片轮转算法")]),_._v(" "),v("p",[_._v("过程：1、排成一个队列。2、每次调度时将CPU分派给队首进程。3、时间片结束时，发生时钟中断。4、暂停当前进程的执行，将其送到就绪队列的末尾，并通过上下文切换执行当前就绪的队首进程。")]),_._v(" "),v("p",[_._v("说明：1、进程阻塞情况发生时，未用完时间片也要出让CPU。2、能够及时响应，但没有考虑作业长短等问题。3、系统的处理能力和系统的负载状态影响时间片长度。")]),_._v(" "),v("p",[_._v("（2）多级反馈队列算法"),v("code",[_._v("FB")])]),_._v(" "),v("p",[_._v("过程：1、准备调度：先将它放入第一个队列的末尾，按"),v("code",[_._v("FCFS")]),_._v("原则排队等待调度。2、若时间片内完成，便可准备撤离系统。3、若时间片内未能完成，调度程序便将该进程转入第二队列的末尾等待再次被调度执行。4、当第一队列中的进程都执行完，系统再按"),v("code",[_._v("FCFS")]),_._v("原则调度第二队列。在第二队列的稍放长些的时间片内仍未完成，再依次将它放入第三队列。5、依次降到第n队列后，在第n队列中便采取按时间片轮转的方式运行。")]),_._v(" "),v("p",[_._v("说明: 1、设置多个就绪队列，各队列有不同的优先级,优先级从第一个队列依次降低。2、赋予各队列进程执行时间片大小不同, 优先权越高，时间片越短。3、仅当优先权高的队列（如第一队列）空闲时，调度程序才调度第二队列中的进程运行。4、高优先级抢占时，被抢占的进程放回原就绪队列末尾。")]),_._v(" "),v("p",[v("img",{attrs:{src:"https://img-blog.csdnimg.cn/bef708b0f5f04d8fb4840e2fe7395088.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_20,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})])])}),[],!1,null,null,null);v.default=s.exports}}]);