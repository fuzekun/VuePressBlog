(window.webpackJsonp=window.webpackJsonp||[]).push([[108],{567:function(v,_,a){"use strict";a.r(_);var t=a(1),r=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h2",{attrs:{id:"基础概念与常识"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基础概念与常识"}},[v._v("#")]),v._v(" 基础概念与常识")]),v._v(" "),_("h3",{attrs:{id:"java-语言有哪些特点"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-语言有哪些特点"}},[v._v("#")]),v._v(" Java 语言有哪些特点?")]),v._v(" "),_("p",[v._v("简单易学；")]),v._v(" "),_("p",[v._v("面向对象（封装，继承，多态）；")]),v._v(" "),_("p",[v._v("平台无关性（ Java 虚拟机实现平台无关性）；")]),v._v(" "),_("p",[v._v("支持多线程（ C++ 语言没有内置的多线程机制，因此必须调用操作系统的多线程功能来进行多线程程序设计，而 Java 语言却提供了多线程支持）；")]),v._v(" "),_("p",[v._v("可靠性；")]),v._v(" "),_("p",[v._v("安全性；")]),v._v(" "),_("p",[v._v("支持网络编程并且很方便（ Java 语言诞生本身就是为简化网络编程设计的，因此 Java 语言不仅支持网络编程而且很方便）；")]),v._v(" "),_("p",[v._v("编译与解释并存；")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"jvm-vs-jdk-vs-jre"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#jvm-vs-jdk-vs-jre"}},[v._v("#")]),v._v(" JVM vs JDK vs JRE")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("JVM")]),v._v(" "),_("p",[v._v("Java 虚拟机（JVM）是运行 Java 字节码的虚拟机。JVM 有针对不同系统的特定实现（Windows，Linux，macOS），目的是使用相同的字节码，它们都会给出相同的结果。字节码和不同系统的 JVM 实现是 Java 语言“一次编译，随处可以运行”的关键所在。")]),v._v(" "),_("p",[_("strong",[v._v("JVM 并不是只有一种！只要满足 JVM 规范，每个公司、组织或者个人都可以开发自己的专属 JVM。")]),v._v(" 也就是说我们平时接触到的 HotSpot VM 仅仅是是 JVM 规范的一种实现而已。")])]),v._v(" "),_("li",[_("p",[v._v("JDK和JRE")]),v._v(" "),_("p",[v._v("JDK 是 Java Development Kit 缩写，它是功能齐全的 Java SDK。它拥有 JRE 所拥有的一切，还有编译器（javac）和工具（如 javadoc 和 jdb）。它能够创建和编译程序。")]),v._v(" "),_("p",[v._v("JRE 是 Java 运行时环境。它是运行已编译 Java 程序所需的所有内容的集合，包括 Java 虚拟机（JVM），Java 类库，java 命令和其他的一些基础构件。但是，它不能用于创建新程序。")]),v._v(" "),_("p",[v._v("如果你只是为了运行一下 Java 程序的话，那么你只需要安装 JRE 就可以了。如果你需要进行一些 Java 编程方面的工作，那么你就需要安装 JDK 了。但是，这不是绝对的。有时，即使您不打算在计算机上进行任何 Java 开发，仍然需要安装 JDK。例如，如果要使用 JSP 部署 Web 应用程序，那么从技术上讲，您只是在应用程序服务器中运行 Java 程序。那你为什么需要 JDK 呢？因为应用程序服务器会将 JSP 转换为 Java servlet，并且需要使用 JDK 来编译 servlet。")])])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"什么是字节码-采用字节码的好处是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是字节码-采用字节码的好处是什么"}},[v._v("#")]),v._v(" 什么是字节码?采用字节码的好处是什么?")]),v._v(" "),_("p",[v._v("在Java中可以理解的代码就叫做字节码（即为.class文件），它不面向任何特定的处理器，只面向虚拟机。Java 语言通过字节码的方式，在一定程度上解决了传统解释型语言执行效率低的问题，同时又保留了解释型语言可移植的特点。所以， Java 程序运行时相对来说还是高效的（不过，和 C++，Rust，Go 等语言还是有一定差距的），而且，由于字节码并不针对一种特定的机器，因此，Java 程序无须重新编译便可在多种不同操作系统的计算机上运行。")]),v._v(" "),_("p",[v._v("我们需要注意的是.class到机器码这一步，在这一步 JVM 类加载器首先加载字节码文件，然后通过解释器逐行解释执行，这种方式的执行速度会相对比较慢。而且，有些方法和代码块是经常需要被调用的(也就是所谓的热点代码)，所以后面引进了 JIT（just-in-time compilation） 编译器，而 JIT 属于运行时编译。当 JIT 编译器完成第一次编译后，其会将字节码对应的机器码保存下来，下次可以直接使用。而我们知道，机器码的运行效率肯定是高于 Java 解释器的。这也解释了我们为什么经常会说 "),_("strong",[v._v("Java 是编译与解释共存的语言")])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"为什么说-java-语言-编译与解释并存"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么说-java-语言-编译与解释并存"}},[v._v("#")]),v._v(" 为什么说 Java 语言“编译与解释并存”？")]),v._v(" "),_("p",[v._v("这是因为 Java 语言既具有编译型语言的特征，也具有解释型语言的特征。因为 Java 程序要经过先编译，后解释两个步骤，由 Java 编写的程序需要先经过编译步骤，生成字节码（"),_("code",[v._v(".class")]),v._v("）这种字节码必须由 Java 解释器来解释执行。")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"java-和-c-的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-和-c-的区别"}},[v._v("#")]),v._v(" Java 和 C++ 的区别?")]),v._v(" "),_("p",[v._v("都是面向对象的，具有封装，继承和多态。")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("Java 不提供指针来直接访问内存，程序内存更加安全")])]),v._v(" "),_("li",[_("p",[v._v("Java 的类是单继承的，C++ 支持多重继承；虽然 Java 的类不可以多继承，但是接口可以多继承。")])]),v._v(" "),_("li",[_("p",[v._v("Java 有自动内存管理垃圾回收机制(GC)，不需要程序员手动释放无用内存。")])]),v._v(" "),_("li",[_("p",[v._v("C ++同时支持方法重载和操作符重载，但是 Java 只支持方法重载（操作符重载增加了复杂性，这与 Java 最初的设计思想不符）。")])])]),v._v(" "),_("h2",{attrs:{id:"基本语法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本语法"}},[v._v("#")]),v._v(" 基本语法")]),v._v(" "),_("h3",{attrs:{id:"注释有哪几种形式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#注释有哪几种形式"}},[v._v("#")]),v._v(" 注释有哪几种形式？")]),v._v(" "),_("p",[v._v("Java 中的注释有三种：")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("单行注释")]),v._v(" ：通常用于解释方法内某单行代码的作用。")]),v._v(" "),_("li",[_("strong",[v._v("多行注释")]),v._v(" ：通常用于解释一段代码的作用。")]),v._v(" "),_("li",[_("strong",[v._v("文档注释")]),v._v(" ：通常用于生成 Java 开发文档。")])]),v._v(" "),_("p",[v._v("用的比较多的还是单行注释和文档注释，多行注释在实际开发中使用的相对较少，代码的注释不是越详细越好。实际上好的代码本身就是注释，我们要尽量规范和美化自己的代码来减少不必要的注释。")]),v._v(" "),_("p",[_("strong",[v._v("若编程语言足够有表达力，就不需要注释，尽量通过代码来阐述")])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"标识符和关键字的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#标识符和关键字的区别是什么"}},[v._v("#")]),v._v(" 标识符和关键字的区别是什么？")]),v._v(" "),_("p",[v._v("在我们编写程序的时候，需要大量地为程序、类、变量、方法等取名字，于是就有了 "),_("strong",[v._v("标识符")]),v._v(" 。简单来说， "),_("strong",[v._v("标识符就是一个名字")]),v._v(" 。")]),v._v(" "),_("p",[v._v("有一些标识符，Java 语言已经赋予了其特殊的含义，只能用于特定的地方，这些特殊的标识符就是 "),_("strong",[v._v("关键字")]),v._v(" 。简单来说，"),_("strong",[v._v("关键字是被赋予特殊含义的标识")]),v._v("符 。比如，在我们的日常生活中，如果我们想要开一家店，则要给这个店起一个名字，起的这个“名字”就叫标识符。但是我们店的名字不能叫“警察局”，因为“警察局”这个名字已经被赋予了特殊的含义，而“警察局”就是我们日常生活中的关键字。")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"java-语言关键字有哪些"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#java-语言关键字有哪些"}},[v._v("#")]),v._v(" Java 语言关键字有哪些？")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"自增自减运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自增自减运算符"}},[v._v("#")]),v._v(" 自增自减运算符")]),v._v(" "),_("p",[v._v("在写代码的过程中，常见的一种情况是需要某个整数类型变量增加 1 或减少 1，Java 提供了一种特殊的运算符，用于这种表达式，叫做自增运算符（++)和自减运算符（--）。")]),v._v(" "),_("p",[v._v("++ 和 -- 运算符可以放在变量之前，也可以放在变量之后，当运算符放在变量之前时(前缀)，先自增/减，再赋值；当运算符放在变量之后时(后缀)，先赋值，再自增/减。例如，当 "),_("code",[v._v("b = ++a")]),v._v(" 时，先自增（自己增加 1），再赋值（赋值给 b）；当 "),_("code",[v._v("b = a++")]),v._v(" 时，先赋值(赋值给 b)，再自增（自己增加 1）。也就是，++a 输出的是 a+1 的值，a++输出的是 a 值。用一句口诀就是：“符号在前就先加/减，符号在后就后加/减”")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"移位运算符"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#移位运算符"}},[v._v("#")]),v._v(" 移位运算符")]),v._v(" "),_("p",[v._v("Java 中有三种移位运算符：")]),v._v(" "),_("ul",[_("li",[_("code",[v._v("<<")]),v._v(" :左移运算符，向左移若干位，高位丢弃，低位补零。"),_("code",[v._v("x << 1")]),v._v(",相当于 x 乘以 2(不溢出的情况下)。")]),v._v(" "),_("li",[_("code",[v._v(">>")]),v._v(" :带符号右移，向右移若干位，高位补符号位，低位丢弃。正数高位补 0,负数高位补 1。"),_("code",[v._v("x >> 1")]),v._v(",相当于 x 除以 2。")]),v._v(" "),_("li",[_("code",[v._v(">>>")]),v._v(" :无符号右移，忽略符号位，空位都以 0 补齐。")])]),v._v(" "),_("p",[v._v("由于 "),_("code",[v._v("double")]),v._v("，"),_("code",[v._v("float")]),v._v(" 在二进制中的表现比较特殊，因此不能来进行移位操作。")]),v._v(" "),_("p",[v._v("移位操作符实际上支持的类型只有"),_("code",[v._v("int")]),v._v("和"),_("code",[v._v("long")]),v._v("，编译器在对"),_("code",[v._v("short")]),v._v("、"),_("code",[v._v("byte")]),v._v("、"),_("code",[v._v("char")]),v._v("类型进行移位前，都会将其转换为"),_("code",[v._v("int")]),v._v("类型再操作。")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"continue、break-和-return-的区别是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#continue、break-和-return-的区别是什么"}},[v._v("#")]),v._v(" continue、break 和 return 的区别是什么？")]),v._v(" "),_("p",[v._v("在循环结构中，当循环条件不满足或者循环次数达到要求时，循环会正常结束。但是，有时候可能需要在循环的过程中，当发生了某种条件之后 ，提前终止循环，这就需要用到下面几个关键词：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("continue")]),v._v(" ：指跳出当前的这一次循环，继续下一次循环。")]),v._v(" "),_("li",[_("code",[v._v("break")]),v._v(" ：指跳出整个循环体，继续执行循环下面的语句。")])]),v._v(" "),_("p",[_("code",[v._v("return")]),v._v(" 用于跳出所在方法，结束该方法的运行。return 一般有两种用法：")]),v._v(" "),_("ol",[_("li",[_("code",[v._v("return;")]),v._v(" ：直接使用 return 结束方法执行，用于没有返回值函数的方法")]),v._v(" "),_("li",[_("code",[v._v("return value;")]),v._v(" ：return 一个特定值，用于有返回值函数的方法")])]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"变量"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#变量"}},[v._v("#")]),v._v(" 变量")]),v._v(" "),_("h4",{attrs:{id:"成员变量与局部变量的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#成员变量与局部变量的区别"}},[v._v("#")]),v._v(" 成员变量与局部变量的区别？")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("语法形式")]),v._v(" ：从语法形式上看，成员变量是属于类的，而局部变量是在代码块或方法中定义的变量或是方法的参数；成员变量可以被 "),_("code",[v._v("public")]),v._v(","),_("code",[v._v("private")]),v._v(","),_("code",[v._v("static")]),v._v(" 等修饰符所修饰，而局部变量不能被访问控制修饰符及 "),_("code",[v._v("static")]),v._v(" 所修饰；但是，成员变量和局部变量都能被 "),_("code",[v._v("final")]),v._v(" 所修饰。")]),v._v(" "),_("li",[_("strong",[v._v("存储方式")]),v._v(" ：从变量在内存中的存储方式来看,如果成员变量是使用 "),_("code",[v._v("static")]),v._v(" 修饰的，那么这个成员变量是属于类的，如果没有使用 "),_("code",[v._v("static")]),v._v(" 修饰，这个成员变量是属于实例的。而对象存在于堆内存，局部变量则存在于栈内存。")]),v._v(" "),_("li",[_("strong",[v._v("生存时间")]),v._v(" ：从变量在内存中的生存时间上看，成员变量是对象的一部分，它随着对象的创建而存在，而局部变量随着方法的调用而自动生成，随着方法的调用结束而消亡。")]),v._v(" "),_("li",[_("strong",[v._v("默认值")]),v._v(" ：从变量是否有默认值来看，成员变量如果没有被赋初始值，则会自动以类型的默认值而赋值（一种情况例外:被 "),_("code",[v._v("final")]),v._v(" 修饰的成员变量也必须显式地赋值），而局部变量则不会自动赋值。")])]),v._v(" "),_("h4",{attrs:{id:"静态变量有什么作用"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态变量有什么作用"}},[v._v("#")]),v._v(" 静态变量有什么作用？")]),v._v(" "),_("p",[v._v("静态变量可以被类的所有实例共享。无论一个类创建了多少个对象，它们都共享同一份静态变量。")]),v._v(" "),_("p",[v._v("通常情况下，静态变量会被 "),_("code",[v._v("final")]),v._v(" 关键字修饰成为常量。")]),v._v(" "),_("h4",{attrs:{id:"字符型常量和字符串常量的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#字符型常量和字符串常量的区别"}},[v._v("#")]),v._v(" 字符型常量和字符串常量的区别?")]),v._v(" "),_("ol",[_("li",[_("strong",[v._v("形式")]),v._v(" : 字符常量是单引号引起的一个字符，字符串常量是双引号引起的 0 个或若干个字符。")]),v._v(" "),_("li",[_("strong",[v._v("含义")]),v._v(" : 字符常量相当于一个整型值( ASCII 值),可以参加表达式运算; 字符串常量代表一个地址值(该字符串在内存中存放位置)。")]),v._v(" "),_("li",[_("strong",[v._v("占内存大小")]),v._v(" ： 字符常量只占 2 个字节; 字符串常量占若干个字节。")])]),v._v(" "),_("p",[v._v("("),_("strong",[v._v("注意： "),_("code",[v._v("char")]),v._v(" 在 Java 中占两个字节")]),v._v(")")]),v._v(" "),_("hr"),v._v(" "),_("h3",{attrs:{id:"方法"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#方法"}},[v._v("#")]),v._v(" 方法")]),v._v(" "),_("h4",{attrs:{id:"什么是方法的返回值-方法有哪几种类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#什么是方法的返回值-方法有哪几种类型"}},[v._v("#")]),v._v(" 什么是方法的返回值?方法有哪几种类型？")]),v._v(" "),_("p",[_("strong",[v._v("方法的返回值")]),v._v(" 是指我们获取到的某个方法体中的代码执行后产生的结果！（前提是该方法可能产生结果）。返回值的作用是接收出结果，使得它可以用于其他的操作！")]),v._v(" "),_("p",[v._v("我们可以按照方法的返回值和参数类型将方法分为 "),_("strong",[v._v("无参数无返回值的方法")]),v._v(" , "),_("strong",[v._v("有参数无返回值的方法")]),v._v(" , "),_("strong",[v._v("有返回值无参数的方法")]),v._v(" , "),_("strong",[v._v("有返回值有参数的方法")]),v._v(" .")]),v._v(" "),_("h4",{attrs:{id:"静态方法为什么不能调用非静态成员"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态方法为什么不能调用非静态成员"}},[v._v("#")]),v._v(" 静态方法为什么不能调用非静态成员?")]),v._v(" "),_("p",[v._v("这个需要结合 JVM 的相关知识，主要原因如下：")]),v._v(" "),_("ol",[_("li",[v._v("静态方法是属于类的，在类加载的时候就会分配内存，可以通过类名直接访问。而非静态成员属于实例对象，只有在对象实例化之后才存在，需要通过类的实例对象去访问。")]),v._v(" "),_("li",[v._v("在类的非静态成员不存在的时候静态成员就已经存在了，此时调用在内存中还不存在的非静态成员，属于非法操作。")])]),v._v(" "),_("h4",{attrs:{id:"静态方法和实例方法有何不同"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#静态方法和实例方法有何不同"}},[v._v("#")]),v._v(" 静态方法和实例方法有何不同？")]),v._v(" "),_("p",[_("strong",[v._v("1、调用方式")])]),v._v(" "),_("p",[v._v("在外部调用静态方法时，可以使用 "),_("code",[v._v("类名.方法名")]),v._v(" 的方式，也可以使用 "),_("code",[v._v("对象.方法名")]),v._v(" 的方式，而实例方法只有后面这种方式。也就是说，"),_("strong",[v._v("调用静态方法可以无需创建对象")]),v._v(" 。")]),v._v(" "),_("p",[v._v("不过，需要注意的是一般不建议使用 "),_("code",[v._v("对象.方法名")]),v._v(" 的方式来调用静态方法。这种方式非常容易造成混淆，静态方法不属于类的某个对象而是属于这个类。")]),v._v(" "),_("p",[v._v("因此，一般建议使用 "),_("code",[v._v("类名.方法名")]),v._v(" 的方式来调用静态方法。")]),v._v(" "),_("p",[_("strong",[v._v("2、访问类成员是否存在限制")])]),v._v(" "),_("p",[v._v("静态方法在访问本类的成员时，只允许访问静态成员（即静态成员变量和静态方法），不允许访问实例成员（即实例成员变量和实例方法），而实例方法不存在这个限制。")]),v._v(" "),_("blockquote",[_("p",[v._v("重载 发生在同一个类中（或者父类和子类之间），方法名必须相同，参数类型不同、个数不同、顺序不同，方法返回值和访问修饰符可以不同")]),v._v(" "),_("p",[v._v("重写发生在运行期，是子类对父类的允许访问的方法的实现过程进行重新编写。")]),v._v(" "),_("ol",[_("li",[v._v("方法名、参数列表必须相同，子类方法返回值类型应比父类方法返回值类型更小或相等，抛出的异常范围小于等于父类，访问修饰符范围大于等于父类。")]),v._v(" "),_("li",[v._v("如果父类方法访问修饰符为 "),_("code",[v._v("private/final/static")]),v._v(" 则子类就不能重写该方法，但是被 "),_("code",[v._v("static")]),v._v(" 修饰的方法能够被再次声明。")]),v._v(" "),_("li",[v._v("构造方法无法被重写")])])]),v._v(" "),_("h4",{attrs:{id:"可变长参数"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#可变长参数"}},[v._v("#")]),v._v(" 可变长参数")]),v._v(" "),_("p",[v._v("从 Java5 开始，Java 支持定义可变长参数，所谓可变长参数就是允许在调用方法时传入不定长度的参数。就比如下面的这个 "),_("code",[v._v("printVariable")]),v._v(" 方法就可以接受 0 个或者多个参数。")]),v._v(" "),_("h3",{attrs:{id:"基本数据类型"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型"}},[v._v("#")]),v._v(" 基本数据类型")]),v._v(" "),_("h4",{attrs:{id:"基本数据类型-2"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本数据类型-2"}},[v._v("#")]),v._v(" 基本数据类型")]),v._v(" "),_("p",[v._v("Java 中有 8 种基本数据类型，分别为：")]),v._v(" "),_("ul",[_("li",[v._v("6 种数字类型：\n"),_("ul",[_("li",[v._v("4 种整数型："),_("code",[v._v("byte")]),v._v("、"),_("code",[v._v("short")]),v._v("、"),_("code",[v._v("int")]),v._v("、"),_("code",[v._v("long")])]),v._v(" "),_("li",[v._v("2 种浮点型："),_("code",[v._v("float")]),v._v("、"),_("code",[v._v("double")])])])]),v._v(" "),_("li",[v._v("1 种字符类型："),_("code",[v._v("char")])]),v._v(" "),_("li",[v._v("1 种布尔型："),_("code",[v._v("boolean")]),v._v("。")])]),v._v(" "),_("p",[v._v("对于 "),_("code",[v._v("boolean")]),v._v("，官方文档未明确定义，它依赖于 JVM 厂商的具体实现。逻辑上理解是占用 1 位，但是实际中会考虑计算机高效存储因素。")]),v._v(" "),_("p",[v._v("另外，Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一")]),v._v(" "),_("p",[v._v("这八种基本类型都有对应的包装类分别为："),_("code",[v._v("Byte")]),v._v("、"),_("code",[v._v("Short")]),v._v("、"),_("code",[v._v("Integer")]),v._v("、"),_("code",[v._v("Long")]),v._v("、"),_("code",[v._v("Float")]),v._v("、"),_("code",[v._v("Double")]),v._v("、"),_("code",[v._v("Character")]),v._v("、"),_("code",[v._v("Boolean")]),v._v(" 。")]),v._v(" "),_("h4",{attrs:{id:"基本类型和包装类型的区别"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#基本类型和包装类型的区别"}},[v._v("#")]),v._v(" 基本类型和包装类型的区别？")]),v._v(" "),_("ul",[_("li",[_("p",[v._v("成员变量包装类型不赋值就是 "),_("code",[v._v("null")]),v._v(" ，而基本类型有默认值且不是 "),_("code",[v._v("null")]),v._v("。")])]),v._v(" "),_("li",[_("p",[v._v("包装类型可用于泛型，而基本类型不可以。")])]),v._v(" "),_("li",[_("p",[v._v("基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 "),_("code",[v._v("static")]),v._v(" 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。")])]),v._v(" "),_("li",[_("p",[v._v("相比于对象类型， 基本数据类型占用的空间非常小。")])])]),v._v(" "),_("p",[_("strong",[v._v("为什么说是几乎所有对象实例呢？")]),v._v(" 这是因为 HotSpot 虚拟机引入了 JIT 优化之后，会对对象进行逃逸分析，如果发现某一个对象并没有逃逸到方法外部，那么就可能通过标量替换来实现栈上分配，而避免堆上分配内存")]),v._v(" "),_("h4",{attrs:{id:"包装类型的缓存机制了解么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#包装类型的缓存机制了解么"}},[v._v("#")]),v._v(" 包装类型的缓存机制了解么？")]),v._v(" "),_("p",[v._v("java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。")]),v._v(" "),_("p",[_("code",[v._v("Byte")]),v._v(","),_("code",[v._v("Short")]),v._v(","),_("code",[v._v("Integer")]),v._v(","),_("code",[v._v("Long")]),v._v(" 这 4 种包装类默认创建了数值 "),_("strong",[v._v("[-128，127]")]),v._v(" 的相应类型的缓存数据，"),_("code",[v._v("Character")]),v._v(" 创建了数值在 "),_("strong",[v._v("[0,127]")]),v._v(" 范围的缓存数据，"),_("code",[v._v("Boolean")]),v._v(" 直接返回 "),_("code",[v._v("True")]),v._v(" or "),_("code",[v._v("False")]),v._v("。")]),v._v(" "),_("p",[v._v("如果超出对应范围仍然会去创建新的对象，缓存的范围区间的大小只是在性能和资源之间的权衡。")]),v._v(" "),_("p",[v._v("两种浮点数类型的包装类 "),_("code",[v._v("Float")]),v._v(","),_("code",[v._v("Double")]),v._v(" 并没有实现缓存机制。")]),v._v(" "),_("p",[_("code",[v._v("Integer i1=40")]),v._v(" 这一行代码会发生装箱，也就是说这行代码等价于  。因此， 直接使用的是缓存中的对象。而 会直接创建新的对象。")]),v._v(" "),_("h4",{attrs:{id:"自动装箱与拆箱了解吗-原理是什么"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#自动装箱与拆箱了解吗-原理是什么"}},[v._v("#")]),v._v(" 自动装箱与拆箱了解吗？原理是什么？")]),v._v(" "),_("p",[_("strong",[v._v("什么是自动拆装箱？")])]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("装箱")]),v._v("：将基本类型用它们对应的引用类型包装起来；")]),v._v(" "),_("li",[_("strong",[v._v("拆箱")]),v._v("：将包装类型转换为基本数据类型；")])]),v._v(" "),_("h4",{attrs:{id:"为什么浮点数运算的时候会有精度丢失的风险"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么浮点数运算的时候会有精度丢失的风险"}},[v._v("#")]),v._v(" 为什么浮点数运算的时候会有精度丢失的风险？")]),v._v(" "),_("p",[v._v("为什么会出现这个问题呢？")]),v._v(" "),_("p",[v._v("这个和计算机保存浮点数的机制有很大关系。我们知道计算机是二进制的，而且计算机在表示一个数字时，宽度是有限的，无限循环的小数存储在计算机时，只能被截断，所以就会导致小数精度发生损失的情况。这也就是解释了为什么浮点数没有办法用二进制精确表示。")]),v._v(" "),_("h4",{attrs:{id:"如何解决浮点数运算的精度丢失问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#如何解决浮点数运算的精度丢失问题"}},[v._v("#")]),v._v(" 如何解决浮点数运算的精度丢失问题？")]),v._v(" "),_("p",[_("code",[v._v("BigDecimal")]),v._v(" 可以实现对浮点数的运算，不会造成精度丢失。通常情况下，大部分需要浮点数精确运算结果的业务场景（比如涉及到钱的场景）都是通过 "),_("code",[v._v("BigDecimal")]),v._v(" 来做的。")]),v._v(" "),_("h4",{attrs:{id:"超过-long-整型的数据应该如何表示"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#超过-long-整型的数据应该如何表示"}},[v._v("#")]),v._v(" 超过 long 整型的数据应该如何表示？")]),v._v(" "),_("p",[v._v("基本数值类型都有一个表达范围，如果超过这个范围就会有数值溢出的风险。")]),v._v(" "),_("p",[v._v("在 Java 中，64 位 long 整型是最大的整数类型。")]),v._v(" "),_("p",[_("code",[v._v("BigInteger")]),v._v(" 内部使用 "),_("code",[v._v("int[]")]),v._v(" 数组来存储任意大小的整形数据。")]),v._v(" "),_("p",[v._v("相对于常规整数类型的运算来说，"),_("code",[v._v("BigInteger")]),v._v(" 运算的效率会相对较低。")])])}),[],!1,null,null,null);_.default=r.exports}}]);