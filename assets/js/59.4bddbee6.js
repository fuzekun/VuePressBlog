(window.webpackJsonp=window.webpackJsonp||[]).push([[59],{518:function(t,_,v){"use strict";v.r(_);var c=v(1),s=Object(c.a)({},(function(){var t=this,_=t._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[_("h3",{attrs:{id:"_1、ioc的理论背景"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_1、ioc的理论背景"}},[t._v("#")]),t._v(" 1、IOC的理论背景")]),t._v(" "),_("p",[t._v("我们知道在面向对象的设计的软件系统中，它的底层是有n个对象构成的，各个对象之间通过相互合作，最终实现系统地业务逻辑。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/1040cca876efce4da6fc0f048ada69ea.png",alt:""}})]),t._v(" "),_("p",[t._v("如果我们打开机械式手表的后盖，就会看到与上面类似的情形，各个齿轮分别带动时针、分针和秒针顺时针旋转，从而在表盘上产生正确的时间。图1中描述的就是这样的一个齿轮组，它拥有多个独立的齿轮，这些齿轮相互啮合在一起，协同工作，共同完成某项任务。我们可以看到，在这样的齿轮组中，如果有一个齿轮出了问题，就可能会影响到整个齿轮组的正常运转。")]),t._v(" "),_("p",[t._v("齿轮组中齿轮之间的啮合关系,与软件系统中对象之间的耦合关系非常相似。对象之间的耦合关系是无法避免的，也是必要的，这是协同工作的基础。现在，伴随着工业级应用的规模越来越庞大，对象之间的依赖关系也越来越复杂，经常会出现对象之间的多重依赖性关系，因此，架构师和设计师对于系统的分析和设计，将面临更大的挑战。对象之间耦合度过高的系统，必然会出现牵一发而动全身的情形。")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://img-blog.csdnimg.cn/img_convert/32cc03522c76e70954360df9c5d89cb7.png",alt:""}})]),t._v(" "),_("p",[t._v("耦合关系不仅会出现在对象与对象之前，也会出现在软件系统的各模块之间，以及软件系统和硬件系统之间的关系。如何降低系统之间、模块之间、对象之间的耦合度，是软件工程永远追求的目标之一。"),_("strong",[t._v("为了解决对象之间的耦合度过高问题，提出IOC理论，实现对象之间的解耦。")])]),t._v(" "),_("h3",{attrs:{id:"_2、为什么是ioc"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_2、为什么是ioc"}},[t._v("#")]),t._v(" 2、为什么是IOC")]),t._v(" "),_("p",[t._v("IOC是Inversion of Control的缩写，多数书籍翻译为“控制反转”。")]),t._v(" "),_("p",[t._v("IOC理论的提出观点大概是这样的："),_("strong",[t._v("“借助于第三方实现具有依赖关系的对象之间的解耦”。")])]),t._v(" "),_("p",[_("img",{attrs:{src:"https://img-blog.csdnimg.cn/63ac5e3292a648bcbb6a069e7f24bcd7.png",alt:"在这里插入图片描述"}})]),t._v(" "),_("p",[t._v("由于引进第三方“IOC容器”，使得A、B、C、D这四个对象没有了耦合关系，齿轮之间的转动全部依靠第三方了，全部对象的控制权全部交给了第三方“IOC”容器，所以IOC容器是整个系统的关键核心，它起到了一种类似“粘合剂”的作用，把系统中的所有对象粘合在一起发挥作用，如果没有了这个粘合剂，对象与对象之间彼此失去了联系，这就是有人把IOC容器比喻成“粘合剂”的由来。")]),t._v(" "),_("p",[t._v("试验：把上面的IOC容器拿掉之后，看看整个系统：")]),t._v(" "),_("p",[_("img",{attrs:{src:"https://img-blog.csdnimg.cn/603b95962cd04e67b8cceee3ce03c441.png",alt:"在这里插入图片描述"}})]),t._v(" "),_("p",[t._v("我们现在看到的画面，就是我们要实现整个系统所需要完成的全部内容。这时候，A、B、C、D这4个对象之间已经没有了耦合关系，彼此毫无联系，这样的话，当你在实现A的时候，根本无须再去考虑B、C和D了，对象之间的依赖关系已经降低到了最低程度。所以，如果真能实现IOC容器，对于系统开发而言，这将是一件多么美好的事情，参与开发的每一成员只要实现自己的类就可以了，跟别人没有任何关系！")]),t._v(" "),_("p",[t._v("我们再来看看，控制反转(IOC)到底为什么要起这么个名字？我们来对比一下：")]),t._v(" "),_("p",[t._v("软件系统在没有引入IOC之前，对象A依赖于对象B，那么在对象A在初始化或者运行到某一点的时候，自己必须主动去创建对象B或者使用已经创建的对象B。但是无论创建还是使用对象B，控制权都在A自己的手上。")]),t._v(" "),_("p",[t._v("软件系统引入IOC容器后，这种情形完全改变了。由于IOC容器的加入，对象A与对象B之间失去了直接联系，所以，当对象A运行到需要对象B的时候，IOC容器会主动创建一个对象B注入到对象A需要的地方。")]),t._v(" "),_("p",[t._v("通过对比可以发现："),_("code",[t._v("对象A获取依赖对象B的过程，由主动行为变成了被动行为，控制权颠倒过来了，所以叫做控制反转")]),t._v("。")]),t._v(" "),_("h3",{attrs:{id:"_3、ioc也叫依赖注入-di"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#_3、ioc也叫依赖注入-di"}},[t._v("#")]),t._v(" 3、IOC也叫依赖注入（DI）")]),t._v(" "),_("p",[t._v("既然IOC是控制反转，那么到底是“哪些方面的控制被反转了呢？”，经过详细地分析和论证后，“获得依赖对象的过程被反转了”。控制反转之后，获得依赖对象的过程由自身管理变成了由IOC容器主动注入。于是，控制反转又叫做“依赖注入”。")]),t._v(" "),_("p",[_("strong",[t._v("所谓依赖注入，就是由IOC容器在运行期间，动态的将某种依赖关系注入到对象中。")])]),t._v(" "),_("p",[t._v("所以，依赖注入（DI）和控制反转（IOC）是从两个不同的角度来描述同一件事，就是指通过引入IOC容器，利用依赖注入的方式，实现对象间的解耦。")])])}),[],!1,null,null,null);_.default=s.exports}}]);