(window.webpackJsonp=window.webpackJsonp||[]).push([[78],{538:function(a,s,t){"use strict";t.r(s);var n=t(1),e=Object(n.a)({},(function(){var a=this,s=a._self._c;return s("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[s("h3",{attrs:{id:"一、内存模型的相关概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#一、内存模型的相关概念"}},[a._v("#")]),a._v(" 一、内存模型的相关概念")]),a._v(" "),s("p",[a._v("大家都知道，计算机在执行程序时，每条指令都是在CPU中执行的，而执行指令过程中，势必涉及到数据的读取和写入。由于程序运行过程中的临时数据是存放在主存（物理内存）当中的，这时就存在一个问题，由于CPU执行速度很快，而从内存读取数据和向内存写入数据的过程跟CPU执行指令的速度比起来要慢的多，因此如果任何时候对数据的操作都要通过和内存的交互来进行，会大大降低指令执行的速度。因此在CPU里面就有了高速缓存。")]),a._v(" "),s("p",[a._v("也就是，当程序在运行过程中，会将运算需要的数据从主存复制一份到CPU的高速缓存当中，那么CPU进行计算时就可以直接从它的高速缓存读取数据和向其中写入数据，当运算结束之后，再将高速缓存中的数据刷新到主存当中。举个简单的例子，比如下面的这段代码：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("当线程执行这个语句时，会先从主存当中读取i的值，然后复制一份到高速缓存当中，然后CPU执行指令对i进行加1操作，然后将数据写入高速缓存，最后将高速缓存中i最新的值刷新到主存当中")]),a._v(" "),s("p",[s("code",[a._v("这个代码在单线程中运行是没有任何问题的，但是在多线程中运行就会有问题了。在多核CPU中，每条线程可能运行于不同的CPU中，因此每个线程运行时有自己的高速缓存")]),a._v("（对单核CPU来说，其实也会出现这种问题，只不过是以线程调度的形式来分别执行的）。本文我们以多核CPU为例。")]),a._v(" "),s("p",[a._v("比如同时有2个线程执行这段代码，假如初始时i的值为0，那么我们希望两个线程执行完之后i的值变为2。但是事实会是这样吗？")]),a._v(" "),s("p",[s("code",[a._v("可能存在下面一种情况：初始时，两个线程分别读取i的值存入各自所在的CPU的高速缓存当中，然后线程1进行加1操作，然后把i的最新值1写入到内存。此时线程2的高速缓存当中i的值还是0，进行加1操作之后，i的值为1，然后线程2把i的值写入内存。")])]),a._v(" "),s("p",[s("code",[a._v("最终结果i的值是1，而不是2。这就是著名的缓存一致性问题。通常称这种被多个线程访问的变量为共享变量。")])]),a._v(" "),s("p",[a._v("也就是说，如果一个变量在多个CPU中都存在缓存（一般在多线程编程时才会出现），那么就可能存在缓存不一致的问题。")]),a._v(" "),s("p",[a._v("为了解决缓存不一致性问题，通常来说有以下2种解决方法：")]),a._v(" "),s("p",[a._v("1）通过在总线加LOCK#锁的方式")]),a._v(" "),s("p",[a._v("2）通过缓存一致性协议")]),a._v(" "),s("p",[a._v("这2种方式都是硬件层面上提供的方式。")]),a._v(" "),s("p",[a._v("在早期的CPU当中，是通过在总线上加LOCK#锁的形式来解决缓存不一致的问题。因为CPU和其他部件进行通信都是通过总线来进行的，如果对总线加LOCK#锁的话，也就是说阻塞了其他CPU对其他部件访问（如内存），从而使得只能有一个CPU能使用这个变量的内存。比如上面例子中 如果一个线程在执行 i = i +1，如果在执行这段代码的过程中，在总线上发出了LCOK#锁的信号，那么只有等待这段代码完全执行完毕之后，其他CPU才能从变量i所在的内存读取变量，然后进行相应的操作。这样就解决了缓存不一致的问题。")]),a._v(" "),s("p",[a._v("但是上面的方式会有一个问题，由于在锁住总线期间，其他CPU无法访问内存，导致效率低下。")]),a._v(" "),s("p",[a._v("所以就出现了缓存一致性协议。最出名的就是Intel 的"),s("code",[a._v("MESI")]),a._v("协议，MESI协议保证了每个缓存中使用的共享变量的副本是一致的.")]),a._v(" "),s("p",[s("strong",[a._v("它核心的思想是：当CPU写数据时，如果发现操作的变量是共享变量，即在其他CPU中也存在该变量的副本，会发出信号通知其他CPU将该变量的缓存行置为无效状态，因此当其他CPU需要读取这个变量时，发现自己缓存中缓存该变量的缓存行是无效的，那么它就会从内存重新读取。")])]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/efd5481c405647889cb4b8d2326c33df.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_18,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("h3",{attrs:{id:"二、并发编程中的三个概念"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#二、并发编程中的三个概念"}},[a._v("#")]),a._v(" 二、并发编程中的三个概念")]),a._v(" "),s("h4",{attrs:{id:"_1、原子性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、原子性"}},[a._v("#")]),a._v(" 1、原子性")]),a._v(" "),s("p",[s("code",[a._v("即一个操作或者多个操作，要么全部执行并且执行过程不会被任何因素打断，要么就都不执行。")])]),a._v(" "),s("p",[a._v("一个很经典的例子就是银行账户转账问题：")]),a._v(" "),s("p",[a._v("比如从账户A向账户B转1000元，那么必然包括2个操作：从账户A减去1000元，往账户B加上1000元。")]),a._v(" "),s("p",[a._v("试想一下，如果这2个操作不具备原子性，会造成什么样的后果。假如从账户A减去1000元之后，操作突然中止。然后又从B取出了500元，取出500元之后，再执行 往账户B加上1000元 的操作。这样就会导致账户A虽然减去了1000元，但是账户B没有收到这个转过来的1000元。")]),a._v(" "),s("p",[a._v("所以这2个操作必须要具备原子性才能保证不出现一些意外的问题。")]),a._v(" "),s("p",[a._v("同样地反映到并发编程中会出现什么结果呢？")]),a._v(" "),s("h4",{attrs:{id:"_2、可见性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、可见性"}},[a._v("#")]),a._v(" 2、可见性")]),a._v(" "),s("p",[a._v("可见性是指多个线程访问同一个变量时，一个线程修改了这个变量的值，其他线程能够立即看到修改的值。")]),a._v(" "),s("p",[a._v("举个简单的例子，看下面这段代码：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程1执行的代码")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("I")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("I")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程2执行的代码")]),a._v("\nj "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("I")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br")])]),s("p",[a._v("假若执行线程1的是CPU1，执行线程2的是CPU2。由上面的分析可知，当线程1执行I = 10这句时，会先把i的初始值加载到CPU1的高速缓存中，然后赋值为10，那么在CPU1的高速缓存当中的i的值就变为10了，却没有立刻写入主存。")]),a._v(" "),s("p",[a._v("此时线程2执行j = I，他会先去主存读取值并加载到CPU2的缓存中，注意此时内存中的i值还是0，那么就会使得j的值变为0，而不是10。")]),a._v(" "),s("p",[s("code",[a._v("这就是可见性问题，线程1对i变量值的修改，线程2没有立刻看见线程1的修改。")])]),a._v(" "),s("h4",{attrs:{id:"_3、有序性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、有序性"}},[a._v("#")]),a._v(" 3、有序性")]),a._v(" "),s("p",[s("code",[a._v("有序性：即程序执行的顺序按照代码的先后顺序执行")])]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("I")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" flag "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("I")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1")]),a._v("\nflag "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("上面的代码定义了一个int型变量，定义了一个Boolean型变量，然后分别对这两个变量进行赋值操作。"),s("code",[a._v("从代码顺序上看，语句1在语句2的前面，那么JVM在真正执行这段代码的时候不一定会保证语句1在语句2之前执行，这里可能会发生指令重排序（Instruction Recorder）")])]),a._v(" "),s("p",[a._v("一般来说，处理器为了提高程序的运行效率，可能会对输入代码进行优化，他不保证程序中各个语句的执行顺讯同代码中的顺序一致，但是它会保证最终执行的结果和代码顺序的执行结果是一致的。")]),a._v(" "),s("p",[a._v("语句1和语句2谁先执行对最终的程序结果并没有影响，那么就有可能在执行过程中，语句2先执行而后语句1后执行。")]),a._v(" "),s("p",[a._v("虽然处理器会对指令进行重排序，但是他会保证程序最终结果会和顺序执行代码的结果相同，如何保证？")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" r "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\na "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("3")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句3")]),a._v("\nr "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" a "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("*")]),a._v(" a"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句4")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("这段代码的执行顺序可能如下：")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/f4a2a370afc24b4396839423185d5070.png",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("但是语句的执行顺序不会为：语句2 -> 语句1 ->语句4 -> 语句3\n因为这样的执行顺序得到的结果与预期的代码顺序下得到的结果显然不同。")]),a._v(" "),s("p",[a._v("虽然重排序不会影响单个线程内程序执行的结果，但是多线程呢？")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程1:")]),a._v("\ncontext "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("loadContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1")]),a._v("\ninited "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\n \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程2:")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("inited "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("doSomethingwithconfig")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("context"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("p",[a._v("上面代码中，由于语句1和语句2没有数据依赖性，因此会被重排序。假如发生重排序，在线程1执行过程中先执行语句2，而此时线程2会以为初始化工作已经完成，那么就会跳出while循环，去执行doSomethingWithconfig(context)方法，而此时context并没有被初始化，会导致程序错误。")]),a._v(" "),s("p",[s("code",[a._v("从上面可以看出，指令重排序不会影响单个线程的执行，但是会影响到线程并发执行的正确性。")])]),a._v(" "),s("p",[s("code",[a._v("也就是说，要想并发程序正确地执行，必须要保证原子性、可见性以及有序性。只要有一个没有被保证，就有可能会导致程序运行不正确。")])]),a._v(" "),s("h3",{attrs:{id:"三、java内存模型"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#三、java内存模型"}},[a._v("#")]),a._v(" 三、Java内存模型")]),a._v(" "),s("p",[a._v("在前面谈到了一些关于内存模型以及并发编程中可能会出现的一些问题。下面我们来看一下Java内存模型，研究一下Java内存模型为我们提供了哪些保证以及在java中提供了哪些方法和机制来让我们在进行多线程编程时能够保证程序执行的正确性。")]),a._v(" "),s("p",[a._v("在Java虚拟机规范中试图定义一种Java内存模型（Java Memory Model，JMM）来屏蔽各个硬件平台和操作系统的内存访问差异，以实现让Java程序在各种平台下都能达到一致的内存访问效果。那么Java内存模型规定了哪些东西呢，它定义了程序中变量的访问规则，往大一点说是定义了程序执行的次序。注意，为了获得较好的执行性能，Java内存模型并没有限制执行引擎使用处理器的寄存器或者高速缓存来提升指令执行速度，也没有限制编译器对指令进行重排序。也就是说，在java内存模型中，也会存在缓存一致性问题和指令重排序的问题。")]),a._v(" "),s("p",[s("strong",[a._v("Java内存模型规定所有的变量都是存在主存当中（类似于前面说的物理内存），每个线程都有自己的工作内存（类似于前面的高速缓存）。线程对变量的所有操作都必须在工作内存中进行，而不能直接对主存进行操作。并且每个线程不能访问其他线程的工作内存。")])]),a._v(" "),s("p",[a._v("举个简单的例子：在java中，执行下面这个语句：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("I")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br")])]),s("p",[a._v("执行线程必须先在自己的工作线程中对变量i所在的缓存进行赋值操作，然后再写入主存中。而不是直接将数值10写入主存当中。")]),a._v(" "),s("h4",{attrs:{id:"_1、原子性-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、原子性-2"}},[a._v("#")]),a._v(" 1、原子性")]),a._v(" "),s("p",[a._v("在java中，对基本数据类型的变量的读取和赋值操作是原子性操作，即这些操作是不可被中断的，要么执行，要么不执行；")]),a._v(" "),s("p",[a._v("分析下列操作哪些是原子性操作？")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[a._v("x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("10")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1")]),a._v("\ny "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("     "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\nx"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("      "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句3")]),a._v("\nx "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" x "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("+")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句4")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br")])]),s("p",[a._v("上述语句只有语句1是原子操作：")]),a._v(" "),s("p",[a._v("语句1是直接将数值赋给x，也就是说线程执行这个语句会直接将数值10写到工作内存中。")]),a._v(" "),s("p",[a._v("语句2实际上包含2个操作，它先要读取x的值，再将x的值写入工作内存，虽然读取x的值以及将x的值写入工作内存，这两个操作都是原子性的，但是合起来就不是原子性操作了。")]),a._v(" "),s("p",[a._v("同样的，x++和x = x +1包括3个操作：读取x的值，进行加1操作，写入新的值。")]),a._v(" "),s("p",[a._v("也就是说只有简单的读取、赋值是原子操作（而且必须是将字面值赋值个某个变量，如果是变量间的相互赋值，也不是原子操作）。")]),a._v(" "),s("p",[a._v("由上：Java内存模型只保存了基本读取和赋值是原子性操作，如果要实现更大范围操作的原子性，可以通过synchronized和lock来实现。由于synchronized和lock能够保证任一时刻只有一个线程执行该代码块，那么自然就不存在原子性问题了，从而保证了原子性。")]),a._v(" "),s("h4",{attrs:{id:"_2、可见性-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、可见性-2"}},[a._v("#")]),a._v(" 2、可见性")]),a._v(" "),s("p",[a._v("对于可见性，Java提供了volatile关键字来保证可见性。\n当一个共享变量被volatile修饰时，他会保证修改的值立即被更新到主存，当有其他线程需要读取时，他会去内存中读取新值。")]),a._v(" "),s("p",[a._v("而普通的共享变量不能保证可见性，因为普通共享变量被修改之后，什么时候被写入主存是不确定的，当其他线程去读取时，此时内存中可能还是原来的旧值，因为无法保证可见性。")]),a._v(" "),s("p",[a._v("另外，通过synchronized和lock也可以保证可见性，synchronized和lock能保证同一时刻只有一个线程获取锁然后执行同步代码块，并且在释放锁之前会将对变量的修改刷新到主存当中。因此可以保证可见性。")]),a._v(" "),s("h4",{attrs:{id:"_3、有序性-2"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、有序性-2"}},[a._v("#")]),a._v(" 3、有序性")]),a._v(" "),s("p",[a._v("在Java内存模型中，允许编译器和处理器对指令进行重排序，但是重排序过程不会影响到单线程的执行结果，却会影响到多线程的执行结果。")]),a._v(" "),s("p",[a._v("在java里面，可以通过volatile关键字来保证一定的“有序性”。另外可以通过synchronized和lock来保证有序性，很显然，synchronized和lock保证每个时刻是有一个线程执行同步代码，相当于是让线程顺序执行同步代码，自然保证了有序性。")]),a._v(" "),s("p",[a._v("另外,"),s("code",[a._v("java内存模型具备一些先天的“有序性”，即不需要通过任何手段就能够得到保证的有序性，这个通常也称为happens-before原则，如果两个操作的执行顺序无法从happens-before原则中推导出来，那么他们就不能保证有序性，虚拟机可以随意的对他们进行重排序。")])]),a._v(" "),s("p",[a._v("下面就来具体介绍下happens-before原则（先行发生原则）：")]),a._v(" "),s("p",[a._v("程序次序规则：一个线程内，按照代码顺序，书写在前面的操作先行发生于书写在后面的操作")]),a._v(" "),s("p",[a._v("锁定规则：一个unLock操作先行发生于后面对同一个锁的lock操作")]),a._v(" "),s("p",[a._v("volatile变量规则：对一个变量的写操作先行发生于后面对这个变量的读操作")]),a._v(" "),s("p",[a._v("传递规则：如果操作A先行发生于操作B，而操作B又先行发生于操作C，则可以得出操作A先行发生于操作C")]),a._v(" "),s("p",[a._v("线程启动规则：Thread对象的start()方法先行发生于此线程的每个一个动作")]),a._v(" "),s("p",[a._v("线程中断规则：对线程interrupt()方法的调用先行发生于被中断线程的代码检测到中断事件的发生")]),a._v(" "),s("p",[a._v("线程终结规则：线程中所有的操作都先行发生于线程的终止检测，我们可以通过Thread.join()方法结束、Thread.isAlive()的返回值手段检测到线程已经终止执行")]),a._v(" "),s("p",[a._v("对象终结规则：一个对象的初始化完成先行发生于他的finalize()方法的开始")]),a._v(" "),s("p",[a._v("对于程序次序规则来说，我的理解就是一段程序代码的执行在单个线程中看起来是有序的。注意，虽然这条规则中提到“书写在前面的操作先行发生于书写在后面的操作”，这个应该是程序看起来执行的顺序是按照代码顺序执行的，因为虚拟机可能会对程序代码进行指令重排序。虽然进行重排序，但是最终执行的结果是与程序顺序执行的结果一致的，"),s("code",[a._v("它只会对不存在数据依赖性的指令进行重排序")]),a._v("。因此，在单个线程中，程序执行看起来是有序执行的，这一点要注意理解。事实上，这个规则是用来保证程序在单线程中执行结果的正确性，但无法保证程序在多线程中执行的正确性。")]),a._v(" "),s("p",[a._v("第二条规则也比较容易理解，也就是说无论在单线程中还是多线程中，同一个锁如果处于被锁定的状态，那么必须先对锁进行了释放操作，后面才能继续进行lock操作。")]),a._v(" "),s("p",[a._v("第三条规则是一条比较重要的规则，也是后文将要重点讲述的内容。直观地解释就是，如果一个线程先去写一个变量，然后一个线程去进行读取，那么写入操作肯定会先行发生于读操作。")]),a._v(" "),s("p",[a._v("第四条规则实际上就是体现happens-before原则具备传递性。")]),a._v(" "),s("h3",{attrs:{id:"四、深入剖析volatile关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#四、深入剖析volatile关键字"}},[a._v("#")]),a._v(" 四、深入剖析volatile关键字")]),a._v(" "),s("h4",{attrs:{id:"_1、volatile关键字的两层语义"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_1、volatile关键字的两层语义"}},[a._v("#")]),a._v(" 1、volatile关键字的两层语义")]),a._v(" "),s("p",[a._v("一旦一个共享变量（类的成员变量、类的静态成员变量）被volatile修饰之后，那么就具备了两层语义；")]),a._v(" "),s("p",[a._v("1）保证了不同线程对这个变量进行操作时的可见性，即一个线程修改了某个变量的值，这新值对其他线程来说是立即可见的；")]),a._v(" "),s("p",[a._v("2）禁止进行指令重排序；")]),a._v(" "),s("p",[a._v("先看一段代码，假如线程1先执行，线程2后执行：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程1")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("boolean")]),a._v(" stop "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("false")]),a._v("；\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("stop"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("doSomething")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程2")]),a._v("\nstop "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),a._v("；\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br")])]),s("p",[a._v("下面解释一下这段代码为何有可能导致无法中断线程。在前面已经解释过，每个线程在运行过程中都有自己的工作内存，那么线程1在运行的时候，会将stop变量的值拷贝一份放在自己的工作内存当中。")]),a._v(" "),s("p",[a._v("那么当线程2更改了stop变量的值之后，但是还没来得及写入主存当中，线程2转去做其他事情了，那么线程1由于不知道线程2对stop变量的更改，因此还会一直循环下去。")]),a._v(" "),s("p",[a._v("但是用volatile修饰之后就变得不一样了：")]),a._v(" "),s("p",[a._v("第一：使用volatile关键字会强制将修改的值立即写入主存；")]),a._v(" "),s("p",[a._v("第二：使用volatile关键字的话，当线程2进行修改时，会导致线程1的工作内存中缓存变量stop的缓存行无效（反映到硬件层的话，就是CPU的L1或者L2缓存中对应的缓存行无效）；")]),a._v(" "),s("p",[a._v("第三：由于线程1的工作内存中缓存变量stop的缓存行无效，所以线程1再次读取变量stop的值时会去主存读取。")]),a._v(" "),s("p",[a._v("那么在线程2修改stop值时（当然这里包括2个操作，修改线程2工作内存中的值，然后将修改后的值写入内存），会使得线程1的工作内存中缓存变量stop的缓存行无效，然后线程1读取时，发现自己的缓存行无效，它会等待缓存行对应的主存地址被更新之后，然后去对应的主存读取最新的值。")]),a._v(" "),s("p",[a._v("那么线程1读取到的就是最新的正确的值。")]),a._v(" "),s("h4",{attrs:{id:"_2、volatile保证原子性吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_2、volatile保证原子性吗"}},[a._v("#")]),a._v(" 2、volatile保证原子性吗？")]),a._v(" "),s("p",[s("img",{attrs:{src:"https://img-blog.csdnimg.cn/6778632463a148bdb4d4c00bbdc55489.png?x-oss-process=image/watermark,type_d3F5LXplbmhlaQ,shadow_50,text_Q1NETiBAbGVlZGNvZGVKb2huMDE=,size_20,color_FFFFFF,t_70,g_se,x_16",alt:"在这里插入图片描述"}})]),a._v(" "),s("p",[a._v("大家想一下这段程序的输出结果是多少？也许有些朋友认为是10000。但是事实上运行它会发现每次运行结果都不一致，都是一个小于10000的数字。")]),a._v(" "),s("p",[a._v("可能有的朋友就会有疑问，不对啊，上面是对变量inc进行自增操作，由于volatile保证了可见性，那么在每个线程中对inc自增完之后，在其他线程中都能看到修改后的值啊，所以有10个线程分别进行了1000次操作，那么最终inc的值应该是1000*10=10000。")]),a._v(" "),s("p",[a._v("这里面就有一个误区了，volatile关键字能保证可见性没有错，但是上面的程序错在没能保证原子性。可见性只能保证每次读取的是最新的值，但是volatile没办法保证对变量的操作的原子性。")]),a._v(" "),s("p",[a._v("在前面已经提到过，自增操作是不具备原子性的，它包括读取变量的原始值、进行加1操作、写入工作内存。那么就是说自增操作的三个子操作可能会分割开执行，就有可能导致下面这种情况出现：")]),a._v(" "),s("p",[a._v("假如某个时刻变量inc的值为10，")]),a._v(" "),s("p",[a._v("线程1对变量进行自增操作，线程1先读取了变量inc的原始值，然后线程1被阻塞了；")]),a._v(" "),s("p",[a._v("然后线程2对变量进行自增操作，线程2也去读取变量inc的原始值，由于线程1只是对变量inc进行读取操作，而没有对变量进行修改操作，所以不会导致线程2的工作内存中缓存变量inc的缓存行无效，所以线程2会直接去主存读取inc的值，发现inc的值时10，然后进行加1操作，并把11写入工作内存，最后写入主存。")]),a._v(" "),s("p",[a._v("然后线程1接着进行加1操作，由于已经读取了inc的值，注意此时在线程1的工作内存中inc的值仍然为10，所以线程1对inc进行加1操作后inc的值为11，然后将11写入工作内存，最后写入主存。")]),a._v(" "),s("p",[a._v("那么两个线程分别进行了一次自增操作后，inc只增加了1。")]),a._v(" "),s("p",[a._v("解释到这里，可能有朋友会有疑问，不对啊，前面不是保证一个变量在修改volatile变量时，会让缓存行无效吗？然后其他线程去读就会读到新的值，对，这个没错。这个就是上面的happens-before规则中的volatile变量规则，但是要注意，线程1对变量进行读取操作之后，被阻塞了的话，并没有对inc值进行修改。然后虽然volatile能保证线程2对变量inc的值读取是从内存中读取的，但是线程1没有进行修改，所以线程2根本就不会看到修改的值。")]),a._v(" "),s("p",[s("strong",[a._v("根源就在这里，自增操作不是原子性操作，而且volatile也无法保证对变量的任何操作都是原子性的。")])]),a._v(" "),s("h4",{attrs:{id:"_3、volatile能保证有序性吗"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_3、volatile能保证有序性吗"}},[a._v("#")]),a._v(" 3、volatile能保证有序性吗？")]),a._v(" "),s("p",[a._v("在前面提到volatile关键字能禁止指令重排序，所以volatile能在一定程度上保证有序性。")]),a._v(" "),s("p",[a._v("volatile关键字禁止指令重排序有两层意思：")]),a._v(" "),s("p",[a._v("1）当程序执行到volatile变量的读操作或者写操作时，在其前面的操作的更改肯定是全部已经进行，且结果已经对后面的操作可见，在其后面的操作肯定还没进行；")]),a._v(" "),s("p",[a._v("2）在进行指令优化时，不能将在对volatile变量访问的语句放在其后面执行，也不能把volatile变量后的语句放在其前面执行。")]),a._v(" "),s("p",[a._v("举个例子:")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//x、y为非volatile变量")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//flag为volatile变量")]),a._v("\nx "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("2")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1")]),a._v("\ny "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\nflag  "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句3")]),a._v("\nx "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("4")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句4")]),a._v("\ny "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("-")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句5")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br")])]),s("p",[a._v("由于flag变量为volatile变量，那么在进行指令重排序的过程的时候，不会将语句3放到语句1、语句2前面，也不会将语句3放到语句4、语句5后面。但是要注意语句1和语句2的顺序，语句4和语句5的顺序不做任何保证。")]),a._v(" "),s("p",[a._v("并且volatile关键字能保证，执行到语句3时，语句1和语句2必定是执行完毕了的，且语句1和语句2的执行结果对语句3、4、5都是可见的。")]),a._v(" "),s("p",[a._v("回到前面的一个例子：")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程1:")]),a._v("\ncontext "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("loadContext")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("   "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句1")]),a._v("\ninited "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token boolean"}},[a._v("true")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("             "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//语句2")]),a._v("\n \n"),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//线程2:")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("while")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("inited "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n      "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" \n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("doSomethingwithconfig")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("context"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br")])]),s("p",[a._v("前面举这个例子的时候，提到有可能语句2会在语句1之前执行，那么就可能导致context还没被初始化，而线程2中就使用未初始化的context去进行操作，导致程序出错。")]),a._v(" "),s("p",[a._v("这里如果用volatile关键字对inited变量进行修饰，就不会出现这种问题了，因为当执行到语句2时，必定能保证context已经初始化完毕。")]),a._v(" "),s("h4",{attrs:{id:"_4、volatile的原理和实现机制"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#_4、volatile的原理和实现机制"}},[a._v("#")]),a._v(" 4、volatile的原理和实现机制")]),a._v(" "),s("p",[a._v("观察加入volatile关键字和没有加入volatile关键字的汇编代码后发现，加入volatile关键字时，会多出一个lock前缀指令。")]),a._v(" "),s("p",[a._v("lock前缀指令实际上相当于一个内存屏障（也称为内存栅栏），内存屏障会提供3个功能：")]),a._v(" "),s("p",[a._v("1）它确保指令重排序时不会把其后面的指令排到内存屏障之前的位置，也不会把前面的指令排到内存屏障之后的位置，即在执行到内存屏障时，在他前面的操作都已经执行完毕了；")]),a._v(" "),s("p",[a._v("2）他会强制将对缓存的修改操作立即写入主存；")]),a._v(" "),s("p",[a._v("3）如果是写操作，它会导致其他CPU中对应的缓存行无效。")]),a._v(" "),s("h3",{attrs:{id:"volatile关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volatile关键字"}},[a._v("#")]),a._v(" volatile关键字")]),a._v(" "),s("h4",{attrs:{id:"如何保证java变量的可见性"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何保证java变量的可见性"}},[a._v("#")]),a._v(" 如何保证Java变量的可见性？")]),a._v(" "),s("p",[s("code",[a._v("volatile")]),a._v(" 关键字其实并非是 Java 语言特有的，在 C 语言里也有，它最原始的意义就是禁用 CPU 缓存。如果我们将一个变量使用 "),s("code",[a._v("volatile")]),a._v(" 修饰，这就指示 编译器，这个变量是共享且不稳定的，每次使用它都到主存中进行读取。")]),a._v(" "),s("p",[s("code",[a._v("volatile")]),a._v(" 关键字能保证数据的可见性，但不能保证数据的原子性。"),s("code",[a._v("synchronized")]),a._v(" 关键字两者都能保证。")]),a._v(" "),s("h4",{attrs:{id:"如何禁止指令重排序"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何禁止指令重排序"}},[a._v("#")]),a._v(" 如何禁止指令重排序？")]),a._v(" "),s("p",[s("strong",[a._v("在 Java 中，"),s("code",[a._v("volatile")]),a._v(" 关键字除了可以保证变量的可见性，还有一个重要的作用就是防止 JVM 的指令重排序。")]),a._v(" 如果我们将变量声明为  ，在对这个变量进行读写操作的时候，会通过插入特定的  的方式来禁止指令重排序")]),a._v(" "),s("p",[a._v("理论上来说，你通过这个三个方法也可以实现和"),s("code",[a._v("volatile")]),a._v("禁止重排序一样的效果，只是会麻烦一些。")]),a._v(" "),s("p",[a._v("下面是单例模式为例讲解一下 "),s("code",[a._v("volatile")]),a._v(" 关键字禁止指令重排序的效果。")]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),a._v(" uniqueInstance"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("private")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v("  "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("getUniqueInstance")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n       "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//先判断对象是否已经实例过，没有实例化过才进入加锁代码")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("uniqueInstance "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("//类对象加锁")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("synchronized")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("if")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("uniqueInstance "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("==")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("null")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                    uniqueInstance "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Singleton")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("return")]),a._v(" uniqueInstance"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br")])]),s("p",[s("code",[a._v("uniqueInstance")]),a._v(" 采用 "),s("code",[a._v("volatile")]),a._v(" 关键字修饰也是很有必要的， "),s("code",[a._v("uniqueInstance = new Singleton();")]),a._v(" 这段代码其实是分为三步执行：")]),a._v(" "),s("ol",[s("li",[a._v("为 "),s("code",[a._v("uniqueInstance")]),a._v(" 分配内存空间")]),a._v(" "),s("li",[a._v("初始化 "),s("code",[a._v("uniqueInstance")])]),a._v(" "),s("li",[a._v("将 "),s("code",[a._v("uniqueInstance")]),a._v(" 指向分配的内存地址")])]),a._v(" "),s("p",[a._v("但是由于 JVM 具有指令重排的特性，执行顺序有可能变成 1->3->2。指令重排在单线程环境下不会出现问题，但是在多线程环境下会导致一个线程获得还没有初始化的实例。例如，线程 T1 执行了 1 和 3，此时 T2 调用 "),s("code",[a._v("getUniqueInstance")]),a._v("() 后发现 "),s("code",[a._v("uniqueInstance")]),a._v(" 不为空，因此返回 "),s("code",[a._v("uniqueInstance")]),a._v("，但此时 "),s("code",[a._v("uniqueInstance")]),a._v(" 还未被初始化。")]),a._v(" "),s("h4",{attrs:{id:"volatile-可以保证原子性么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#volatile-可以保证原子性么"}},[a._v("#")]),a._v(" volatile 可以保证原子性么？")]),a._v(" "),s("p",[s("strong",[s("code",[a._v("volatile")]),a._v(" 关键字能保证变量的可见性，但不能保证对变量的操作是原子性的。")])]),a._v(" "),s("div",{staticClass:"language-java line-numbers-mode"},[s("pre",{pre:!0,attrs:{class:"language-java"}},[s("code",[s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("VolatoleAtomicityDemo")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("volatile")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" inc "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("increase")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        inc"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n    "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("public")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("static")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("void")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("main")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("String")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" args"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("throws")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("InterruptedException")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("ExecutorService")]),a._v(" threadPool "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Executors")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("newFixedThreadPool")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("VolatoleAtomicityDemo")]),a._v(" volatoleAtomicityDemo "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("new")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("VolatoleAtomicityDemo")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("5")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" i"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n            threadPool"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("execute")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("->")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("int")]),a._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("0")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" j "),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("<")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("500")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v(" j"),s("span",{pre:!0,attrs:{class:"token operator"}},[a._v("++")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v(" "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n                    volatoleAtomicityDemo"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("increase")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n                "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n            "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// 等待1.5秒，保证上面程序执行完成")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Thread")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("sleep")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token number"}},[a._v("1500")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        "),s("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("System")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("out"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("println")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("inc"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n        threadPool"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),s("span",{pre:!0,attrs:{class:"token function"}},[a._v("shutdown")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(";")]),a._v("\n    "),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n"),s("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])]),a._v(" "),s("div",{staticClass:"line-numbers-wrapper"},[s("span",{staticClass:"line-number"},[a._v("1")]),s("br"),s("span",{staticClass:"line-number"},[a._v("2")]),s("br"),s("span",{staticClass:"line-number"},[a._v("3")]),s("br"),s("span",{staticClass:"line-number"},[a._v("4")]),s("br"),s("span",{staticClass:"line-number"},[a._v("5")]),s("br"),s("span",{staticClass:"line-number"},[a._v("6")]),s("br"),s("span",{staticClass:"line-number"},[a._v("7")]),s("br"),s("span",{staticClass:"line-number"},[a._v("8")]),s("br"),s("span",{staticClass:"line-number"},[a._v("9")]),s("br"),s("span",{staticClass:"line-number"},[a._v("10")]),s("br"),s("span",{staticClass:"line-number"},[a._v("11")]),s("br"),s("span",{staticClass:"line-number"},[a._v("12")]),s("br"),s("span",{staticClass:"line-number"},[a._v("13")]),s("br"),s("span",{staticClass:"line-number"},[a._v("14")]),s("br"),s("span",{staticClass:"line-number"},[a._v("15")]),s("br"),s("span",{staticClass:"line-number"},[a._v("16")]),s("br"),s("span",{staticClass:"line-number"},[a._v("17")]),s("br"),s("span",{staticClass:"line-number"},[a._v("18")]),s("br"),s("span",{staticClass:"line-number"},[a._v("19")]),s("br"),s("span",{staticClass:"line-number"},[a._v("20")]),s("br"),s("span",{staticClass:"line-number"},[a._v("21")]),s("br"),s("span",{staticClass:"line-number"},[a._v("22")]),s("br"),s("span",{staticClass:"line-number"},[a._v("23")]),s("br")])]),s("p",[a._v("很多人会误认为自增操作 "),s("code",[a._v("inc++")]),a._v(" 是原子性的，实际上，"),s("code",[a._v("inc++")]),a._v(" 其实是一个复合操作，包括三步：")]),a._v(" "),s("ol",[s("li",[a._v("读取 inc 的值。")]),a._v(" "),s("li",[a._v("对 inc 加 1。")]),a._v(" "),s("li",[a._v("将 inc 的值写回内存。")])]),a._v(" "),s("p",[s("code",[a._v("volatile")]),a._v(" 是无法保证这三个操作是具有原子性的，有可能导致下面这种情况出现：")]),a._v(" "),s("ol",[s("li",[a._v("线程 1 对 "),s("code",[a._v("inc")]),a._v(" 进行读取操作之后，还未对其进行修改。线程 2 又读取了 "),s("code",[a._v("inc")]),a._v("的值并对其进行修改（+1），再将"),s("code",[a._v("inc")]),a._v(" 的值写回内存。")]),a._v(" "),s("li",[a._v("线程 2 操作完毕后，线程 1 对 "),s("code",[a._v("inc")]),a._v("的值进行修改（+1），再将"),s("code",[a._v("inc")]),a._v(" 的值写回内存。")])]),a._v(" "),s("p",[a._v("这也就导致两个线程分别对 "),s("code",[a._v("inc")]),a._v(" 进行了一次自增操作后，"),s("code",[a._v("inc")]),a._v(" 实际上只增加了 1。")]),a._v(" "),s("p",[a._v("其实，如果想要保证上面的代码运行正确也非常简单，利用 "),s("code",[a._v("synchronized")]),a._v(" 、"),s("code",[a._v("Lock")]),a._v("或者"),s("code",[a._v("AtomicInteger")]),a._v("都可以。")]),a._v(" "),s("h3",{attrs:{id:"synchronized-关键字"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-关键字"}},[a._v("#")]),a._v(" synchronized 关键字")]),a._v(" "),s("h4",{attrs:{id:"synchronized-是什么-有什么用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-是什么-有什么用"}},[a._v("#")]),a._v(" synchronized 是什么？有什么用？")]),a._v(" "),s("p",[s("code",[a._v("synchronized")]),a._v(" 是 Java 中的一个关键字，翻译成中文是同步的意思，主要解决的是多个线程之间访问资源的同步性，可以保证被它修饰的方法或者代码块在任意时刻只能有一个线程执行。")]),a._v(" "),s("p",[a._v("在 Java 早期版本中，"),s("code",[a._v("synchronized")]),a._v(" 属于 "),s("strong",[a._v("重量级锁")]),a._v("，效率低下。这是因为监视器锁（monitor）是依赖于底层的操作系统的 "),s("code",[a._v("Mutex Lock")]),a._v(" 来实现的，Java 的线程是映射到操作系统的原生线程之上的。如果要挂起或者唤醒一个线程，都需要操作系统帮忙完成，而操作系统实现线程之间的切换时需要从用户态转换到内核态，这个状态之间的转换需要相对比较长的时间，时间成本相对较高。")]),a._v(" "),s("p",[a._v("不过，在 Java 6 之后， "),s("code",[a._v("synchronized")]),a._v(" 引入了大量的优化如自旋锁、适应性自旋锁、锁消除、锁粗化、偏向锁、轻量级锁等技术来减少锁操作的开销，这些优化让 "),s("code",[a._v("synchronized")]),a._v(" 锁的效率提升了很多。因此， "),s("code",[a._v("synchronized")]),a._v(" 还是可以在实际项目中使用的，像 JDK 源码、很多开源框架都大量使用了 "),s("code",[a._v("synchronized")]),a._v(" 。")]),a._v(" "),s("h4",{attrs:{id:"如何使用-synchronized"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#如何使用-synchronized"}},[a._v("#")]),a._v(" 如何使用 synchronized？")]),a._v(" "),s("p",[s("code",[a._v("synchronized")]),a._v(" 关键字的使用方式主要有下面 3 种：")]),a._v(" "),s("ol",[s("li",[a._v("修饰实例方法")]),a._v(" "),s("li",[a._v("修饰静态方法")]),a._v(" "),s("li",[a._v("修饰代码块")])]),a._v(" "),s("p",[s("strong",[a._v("1、修饰实例方法")]),a._v(" （锁当前对象实例）")]),a._v(" "),s("p",[a._v("给当前对象实例加锁，进入同步代码前要获得 "),s("strong",[a._v("当前对象实例的锁")]),a._v(" 。")]),a._v(" "),s("p",[s("strong",[a._v("2、修饰静态方法")]),a._v(" （锁当前类）")]),a._v(" "),s("p",[a._v("给当前类加锁，会作用于类的所有对象实例 ，进入同步代码前要获得 "),s("strong",[a._v("当前 class 的锁")]),a._v("。")]),a._v(" "),s("p",[a._v("这是因为静态成员不属于任何一个实例对象，归整个类所有，不依赖于类的特定实例，被类的所有实例共享。")]),a._v(" "),s("p",[s("strong",[a._v("3、修饰代码块")]),a._v(" （锁指定对象/类）")]),a._v(" "),s("p",[a._v("对括号里指定的对象/类加锁：")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("synchronized(object)")]),a._v(" 表示进入同步代码库前要获得 "),s("strong",[a._v("给定对象的锁")]),a._v("。")]),a._v(" "),s("li",[s("code",[a._v("synchronized(类.class)")]),a._v(" 表示进入同步代码前要获得 "),s("strong",[a._v("给定 Class 的锁")])])]),a._v(" "),s("p",[s("strong",[a._v("总结：")])]),a._v(" "),s("ul",[s("li",[s("code",[a._v("synchronized")]),a._v(" 关键字加到 "),s("code",[a._v("static")]),a._v(" 静态方法和 "),s("code",[a._v("synchronized(class)")]),a._v(" 代码块上都是是给 Class 类上锁；")]),a._v(" "),s("li",[s("code",[a._v("synchronized")]),a._v(" 关键字加到实例方法上是给对象实例上锁；")]),a._v(" "),s("li",[a._v("尽量不要使用 "),s("code",[a._v("synchronized(String a)")]),a._v(" 因为 JVM 中，字符串常量池具有缓存功能。")])]),a._v(" "),s("h4",{attrs:{id:"构造方法可以用-synchronized-修饰么"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#构造方法可以用-synchronized-修饰么"}},[a._v("#")]),a._v(" 构造方法可以用 synchronized 修饰么？")]),a._v(" "),s("p",[a._v("先说结论："),s("strong",[a._v("构造方法不能使用 synchronized 关键字修饰。")])]),a._v(" "),s("p",[a._v("构造方法本身就属于线程安全的，不存在同步的构造方法一说。")]),a._v(" "),s("h4",{attrs:{id:"synchronized-底层原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-底层原理"}},[a._v("#")]),a._v(" synchronized 底层原理")]),a._v(" "),s("p",[s("strong",[a._v("synchronized 同步语句块的情况")])]),a._v(" "),s("p",[a._v("从上面我们可以看出："),s("strong",[s("code",[a._v("synchronized")]),a._v(" 同步语句块的实现使用的是 "),s("code",[a._v("monitorenter")]),a._v(" 和 "),s("code",[a._v("monitorexit")]),a._v(" 指令，其中 "),s("code",[a._v("monitorenter")]),a._v(" 指令指向同步代码块的开始位置，"),s("code",[a._v("monitorexit")]),a._v(" 指令则指明同步代码块的结束位置。")])]),a._v(" "),s("p",[a._v("当执行 "),s("code",[a._v("monitorenter")]),a._v(" 指令时，线程试图获取锁也就是获取 "),s("strong",[a._v("对象监视器 "),s("code",[a._v("monitor")])]),a._v(" 的持有权。")]),a._v(" "),s("blockquote",[s("p",[a._v("在 Java 虚拟机(HotSpot)中，Monitor 是基于 C++实现的，由"),s("a",{attrs:{href:"https://github.com/openjdk-mirror/jdk7u-hotspot/blob/50bdefc3afe944ca74c3093e7448d6b889cd20d1/src/share/vm/runtime/objectMonitor.cpp",target:"_blank",rel:"noopener noreferrer"}},[a._v("ObjectMonitoropen in new window"),s("OutboundLink")],1),a._v("实现的。每个对象中都内置了一个 "),s("code",[a._v("ObjectMonitor")]),a._v("对象。")]),a._v(" "),s("p",[a._v("另外，"),s("code",[a._v("wait/notify")]),a._v("等方法也依赖于"),s("code",[a._v("monitor")]),a._v("对象，这就是为什么只有在同步的块或者方法中才能调用"),s("code",[a._v("wait/notify")]),a._v("等方法，否则会抛出"),s("code",[a._v("java.lang.IllegalMonitorStateException")]),a._v("的异常的原因。")])]),a._v(" "),s("p",[a._v("在执行"),s("code",[a._v("monitorenter")]),a._v("时，会尝试获取对象的锁，如果锁的计数器为 0 则表示锁可以被获取，获取后将锁计数器设为 1 也就是加 1。")]),a._v(" "),s("p",[a._v("对象锁的的拥有者线程才可以执行 "),s("code",[a._v("monitorexit")]),a._v(" 指令来释放锁。在执行 "),s("code",[a._v("monitorexit")]),a._v(" 指令后，将锁计数器设为 0，表明锁被释放，其他线程可以尝试获取锁。")]),a._v(" "),s("p",[a._v("如果获取对象锁失败，那当前线程就要阻塞等待，直到锁被另外一个线程释放为止。")]),a._v(" "),s("p",[s("strong",[a._v("synchronized 修饰方法的的情况")])]),a._v(" "),s("p",[s("code",[a._v("synchronized")]),a._v(" 修饰的方法并没有 "),s("code",[a._v("monitorenter")]),a._v(" 指令和 "),s("code",[a._v("monitorexit")]),a._v(" 指令，取得代之的确实是 "),s("code",[a._v("ACC_SYNCHRONIZED")]),a._v(" 标识，该标识指明了该方法是一个同步方法。JVM 通过该 "),s("code",[a._v("ACC_SYNCHRONIZED")]),a._v(" 访问标志来辨别一个方法是否声明为同步方法，从而执行相应的同步调用。")]),a._v(" "),s("p",[a._v("如果是实例方法，JVM 会尝试获取实例对象的锁。如果是静态方法，JVM 会尝试获取当前 class 的锁。")]),a._v(" "),s("p",[s("strong",[a._v("不过两者的本质都是对对象监视器 monitor 的获取。")])]),a._v(" "),s("h4",{attrs:{id:"jdk1-6-之后的-synchronized-底层做了哪些优化"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jdk1-6-之后的-synchronized-底层做了哪些优化"}},[a._v("#")]),a._v(" JDK1.6 之后的 synchronized 底层做了哪些优化？")]),a._v(" "),s("p",[a._v("JDK1.6 对锁的实现引入了大量的优化，如偏向锁、轻量级锁、自旋锁、适应性自旋锁、锁消除、锁粗化等技术来减少锁操作的开销。")]),a._v(" "),s("p",[a._v("锁主要存在四种状态，依次是：无锁状态、偏向锁状态、轻量级锁状态、重量级锁状态，他们会随着竞争的激烈而逐渐升级。注意锁可以升级不可降级，这种策略是为了提高获得锁和释放锁的效率。")]),a._v(" "),s("p",[s("a",{attrs:{href:"https://www.cnblogs.com/wuqinglong/p/9945618.html",target:"_blank",rel:"noopener noreferrer"}},[a._v("具体原理"),s("OutboundLink")],1)]),a._v(" "),s("h4",{attrs:{id:"synchronized-和-volatile-有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-和-volatile-有什么区别"}},[a._v("#")]),a._v(" synchronized 和 volatile 有什么区别？")]),a._v(" "),s("p",[s("code",[a._v("synchronized")]),a._v(" 关键字和 "),s("code",[a._v("volatile")]),a._v(" 关键字是两个互补的存在，而不是对立的存在！")]),a._v(" "),s("ul",[s("li",[s("code",[a._v("volatile")]),a._v(" 关键字是线程同步的轻量级实现，所以 "),s("code",[a._v("volatile")]),a._v("性能肯定比"),s("code",[a._v("synchronized")]),a._v("关键字要好 。但是 "),s("code",[a._v("volatile")]),a._v(" 关键字只能用于变量而 "),s("code",[a._v("synchronized")]),a._v(" 关键字可以修饰方法以及代码块 。")]),a._v(" "),s("li",[s("code",[a._v("volatile")]),a._v(" 关键字能保证数据的可见性，但不能保证数据的原子性。"),s("code",[a._v("synchronized")]),a._v(" 关键字两者都能保证。")]),a._v(" "),s("li",[s("code",[a._v("volatile")]),a._v("关键字主要用于解决变量在多个线程之间的可见性，而 "),s("code",[a._v("synchronized")]),a._v(" 关键字解决的是多个线程之间访问资源的同步性")])]),a._v(" "),s("h4",{attrs:{id:"synchronized-和-reentrantlock-有什么区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#synchronized-和-reentrantlock-有什么区别"}},[a._v("#")]),a._v(" synchronized 和 ReentrantLock 有什么区别？")]),a._v(" "),s("p",[s("strong",[a._v("两者都是可重入锁")])]),a._v(" "),s("p",[s("strong",[a._v("“可重入锁”")]),a._v(" 指的是自己可以再次获取自己的内部锁。比如一个线程获得了某个对象的锁，此时这个对象锁还没有释放，当其再次想要获取这个对象的锁的时候还是可以获取的，如果是不可重入锁的话，就会造成死锁。同一个线程每次获取锁，锁的计数器都自增 1，所以要等到锁的计数器下降为 0 时才能释放锁。")]),a._v(" "),s("p",[s("strong",[a._v("JDK 提供的所有现成的 "),s("code",[a._v("Lock")]),a._v(" 实现类，包括 "),s("code",[a._v("synchronized")]),a._v(" 关键字锁都是可重入的。")])]),a._v(" "),s("p",[s("strong",[a._v("synchronized 依赖于 JVM 而 ReentrantLock 依赖于 API")])]),a._v(" "),s("p",[s("code",[a._v("synchronized")]),a._v(" 是依赖于 JVM 实现的，前面我们也讲到了 虚拟机团队在 JDK1.6 为 "),s("code",[a._v("synchronized")]),a._v(" 关键字进行了很多优化，但是这些优化都是在虚拟机层面实现的，并没有直接暴露给我们。")]),a._v(" "),s("p",[s("code",[a._v("ReentrantLock")]),a._v(" 是 JDK 层面实现的（也就是 API 层面，需要 lock() 和 unlock() 方法配合 try/finally 语句块来完成），所以我们可以通过查看它的源代码，来看它是如何实现的。")]),a._v(" "),s("p",[s("strong",[a._v("ReentrantLock 比 synchronized 增加了一些高级功能")])]),a._v(" "),s("p",[a._v("相比"),s("code",[a._v("synchronized")]),a._v("，"),s("code",[a._v("ReentrantLock")]),a._v("增加了一些高级功能。主要来说主要有三点：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("等待可中断")]),a._v(" : "),s("code",[a._v("ReentrantLock")]),a._v("提供了一种能够中断等待锁的线程的机制，通过 "),s("code",[a._v("lock.lockInterruptibly()")]),a._v(" 来实现这个机制。也就是说正在等待的线程可以选择放弃等待，改为处理其他事情。")]),a._v(" "),s("li",[s("strong",[a._v("可实现公平锁")]),a._v(" : "),s("code",[a._v("ReentrantLock")]),a._v("可以指定是公平锁还是非公平锁。而"),s("code",[a._v("synchronized")]),a._v("只能是非公平锁。所谓的公平锁就是先等待的线程先获得锁。"),s("code",[a._v("ReentrantLock")]),a._v("默认情况是非公平的，可以通过 "),s("code",[a._v("ReentrantLock")]),a._v("类的"),s("code",[a._v("ReentrantLock(boolean fair)")]),a._v("构造方法来制定是否是公平的。")]),a._v(" "),s("li",[s("strong",[a._v("可实现选择性通知（锁可以绑定多个条件）")]),a._v(": "),s("code",[a._v("synchronized")]),a._v("关键字与"),s("code",[a._v("wait()")]),a._v("和"),s("code",[a._v("notify()")]),a._v("/"),s("code",[a._v("notifyAll()")]),a._v("方法相结合可以实现等待/通知机制。"),s("code",[a._v("ReentrantLock")]),a._v("类当然也可以实现，但是需要借助于"),s("code",[a._v("Condition")]),a._v("接口与"),s("code",[a._v("newCondition()")]),a._v("方法")])]),a._v(" "),s("p",[a._v("关于公平锁和非公平锁的补充：")]),a._v(" "),s("blockquote",[s("ul",[s("li",[s("strong",[a._v("公平锁")]),a._v(" : 锁被释放之后，先申请的线程/进程先得到锁。")]),a._v(" "),s("li",[s("strong",[a._v("非公平锁")]),a._v(" ：锁被释放之后，后申请的线程/进程可能会先获取到锁，是随机或者按照其他优先级排序的。")])])]),a._v(" "),s("p",[a._v("关于 "),s("code",[a._v("Condition")]),a._v("接口的补充：")]),a._v(" "),s("blockquote",[s("p",[s("code",[a._v("Condition")]),a._v("是 JDK1.5 之后才有的，它具有很好的灵活性，比如可以实现多路通知功能也就是在一个"),s("code",[a._v("Lock")]),a._v("对象中可以创建多个"),s("code",[a._v("Condition")]),a._v("实例（即对象监视器），"),s("strong",[a._v("线程对象可以注册在指定的"),s("code",[a._v("Condition")]),a._v("中，从而可以有选择性的进行线程通知，在调度线程上更加灵活。 在使用"),s("code",[a._v("notify()/notifyAll()")]),a._v("方法进行通知时，被通知的线程是由 JVM 选择的，用"),s("code",[a._v("ReentrantLock")]),a._v("类结合"),s("code",[a._v("Condition")]),a._v("实例可以实现“选择性通知”")]),a._v(" ，这个功能非常重要，而且是 "),s("code",[a._v("Condition")]),a._v(" 接口默认提供的。而"),s("code",[a._v("synchronized")]),a._v("关键字就相当于整个 "),s("code",[a._v("Lock")]),a._v(" 对象中只有一个"),s("code",[a._v("Condition")]),a._v("实例，所有的线程都注册在它一个身上。如果执行"),s("code",[a._v("notifyAll()")]),a._v("方法的话就会通知所有处于等待状态的线程，这样会造成很大的效率问题。而"),s("code",[a._v("Condition")]),a._v("实例的"),s("code",[a._v("signalAll()")]),a._v("方法，只会唤醒注册在该"),s("code",[a._v("Condition")]),a._v("实例中的所有等待线程。")])]),a._v(" "),s("h3",{attrs:{id:"threadlocal"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal"}},[a._v("#")]),a._v(" ThreadLocal")]),a._v(" "),s("h4",{attrs:{id:"threadlocal-有什么用"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-有什么用"}},[a._v("#")]),a._v(" ThreadLocal 有什么用？")]),a._v(" "),s("p",[a._v("通常情况下，我们创建的变量是可以被任何一个线程访问并修改的。"),s("strong",[a._v("如果想实现每一个线程都有自己的专属本地变量该如何解决呢？")])]),a._v(" "),s("p",[a._v("JDK 中自带的"),s("code",[a._v("ThreadLocal")]),a._v("类正是为了解决这样的问题。 "),s("strong",[s("code",[a._v("ThreadLocal")]),a._v("类主要解决的就是让每个线程绑定自己的值，可以将"),s("code",[a._v("ThreadLocal")]),a._v("类形象的比喻成存放数据的盒子，盒子中可以存储每个线程的私有数据。")])]),a._v(" "),s("p",[a._v("如果你创建了一个"),s("code",[a._v("ThreadLocal")]),a._v("变量，那么访问这个变量的每个线程都会有这个变量的本地副本，这也是"),s("code",[a._v("ThreadLocal")]),a._v("变量名的由来。他们可以使用 "),s("code",[a._v("get()")]),a._v(" 和 "),s("code",[a._v("set()")]),a._v(" 方法来获取默认值或将其值更改为当前线程所存的副本的值，从而避免了线程安全问题。")]),a._v(" "),s("p",[a._v("再举个简单的例子：两个人去宝屋收集宝物，这两个共用一个袋子的话肯定会产生争执，但是给他们两个人每个人分配一个袋子的话就不会出现这样的问题。如果把这两个人比作线程的话，那么 ThreadLocal 就是用来避免这两个线程竞争的")]),a._v(" "),s("h4",{attrs:{id:"threadlocal-原理"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-原理"}},[a._v("#")]),a._v(" ThreadLocal 原理")]),a._v(" "),s("p",[s("strong",[a._v("最终的变量是放在了当前线程的 "),s("code",[a._v("ThreadLocalMap")]),a._v(" 中，并不是存在 "),s("code",[a._v("ThreadLocal")]),a._v(" 上，"),s("code",[a._v("ThreadLocal")]),a._v(" 可以理解为只是"),s("code",[a._v("ThreadLocalMap")]),a._v("的封装，传递了变量值。")]),a._v(" "),s("code",[a._v("ThrealLocal")]),a._v(" 类中可以通过"),s("code",[a._v("Thread.currentThread()")]),a._v("获取到当前线程对象后，直接通过"),s("code",[a._v("getMap(Thread t)")]),a._v("可以访问到该线程的"),s("code",[a._v("ThreadLocalMap")]),a._v("对象。")]),a._v(" "),s("p",[s("strong",[a._v("每个"),s("code",[a._v("Thread")]),a._v("中都具备一个"),s("code",[a._v("ThreadLocalMap")]),a._v("，而"),s("code",[a._v("ThreadLocalMap")]),a._v("可以存储以"),s("code",[a._v("ThreadLocal")]),a._v("为 key ，Object 对象为 value 的键值对。")])]),a._v(" "),s("p",[s("code",[a._v("ThreadLocalMap")]),a._v("是"),s("code",[a._v("ThreadLocal")]),a._v("的静态内部类。")]),a._v(" "),s("h4",{attrs:{id:"threadlocal-内存泄露问题是怎么导致的"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#threadlocal-内存泄露问题是怎么导致的"}},[a._v("#")]),a._v(" ThreadLocal 内存泄露问题是怎么导致的？")]),a._v(" "),s("p",[s("code",[a._v("ThreadLocalMap")]),a._v(" 中使用的 key 为 "),s("code",[a._v("ThreadLocal")]),a._v(" 的弱引用，而 value 是强引用。所以，如果 "),s("code",[a._v("ThreadLocal")]),a._v(" 没有被外部强引用的情况下，在垃圾回收的时候，key 会被清理掉，而 value 不会被清理掉。")]),a._v(" "),s("p",[a._v("这样一来，"),s("code",[a._v("ThreadLocalMap")]),a._v(" 中就会出现 key 为 null 的 Entry。假如我们不做任何措施的话，value 永远无法被 GC 回收，这个时候就可能会产生内存泄露。"),s("code",[a._v("ThreadLocalMap")]),a._v(" 实现中已经考虑了这种情况，在调用 "),s("code",[a._v("set()")]),a._v("、"),s("code",[a._v("get()")]),a._v("、"),s("code",[a._v("remove()")]),a._v(" 方法的时候，会清理掉 key 为 null 的记录。使用完 "),s("code",[a._v("ThreadLocal")]),a._v("方法后 最好手动调用"),s("code",[a._v("remove()")]),a._v("方法")]),a._v(" "),s("hr"),a._v(" "),s("p",[s("strong",[a._v("重要知识点")])]),a._v(" "),s("h3",{attrs:{id:"jmm-是如何抽象线程和主内存之间的关系"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#jmm-是如何抽象线程和主内存之间的关系"}},[a._v("#")]),a._v(" JMM 是如何抽象线程和主内存之间的关系？")]),a._v(" "),s("p",[s("strong",[a._v("Java 内存模型（JMM）")]),a._v(" 抽象了线程和主内存之间的关系，就比如说线程之间的共享变量必须存储在主内存中。")]),a._v(" "),s("p",[a._v("在 JDK1.2 之前，Java 的内存模型实现总是从 "),s("strong",[a._v("主存")]),a._v(" （即共享内存）读取变量，是不需要进行特别的注意的。而在当前的 Java 内存模型下，线程可以把变量保存 "),s("strong",[a._v("本地内存")]),a._v(" （比如机器的寄存器）中，而不是直接在主存中进行读写。这就可能造成一个线程在主存中修改了一个变量的值，而另外一个线程还继续使用它在寄存器中的变量值的拷贝，造成数据的不一致。")]),a._v(" "),s("p",[a._v("这和我们上面讲到的 CPU 缓存模型非常相似。")]),a._v(" "),s("p",[s("strong",[a._v("什么是主内存？什么是本地内存？")])]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("主内存")]),a._v(" ：所有线程创建的实例对象都存放在主内存中，不管该实例对象是成员变量还是方法中的本地变量(也称局部变量)")]),a._v(" "),s("li",[s("strong",[a._v("本地内存")]),a._v(" ：每个线程都有一个私有的本地内存来存储共享变量的副本，并且，每个线程只能访问自己的本地内存，无法访问其他线程的本地内存。本地内存是 JMM 抽象出来的一个概念，存储了主内存中的共享变量副本。")])]),a._v(" "),s("p",[a._v("线程 1 与线程 2 之间如果要进行通信的话，必须要经历下面 2 个步骤：")]),a._v(" "),s("ol",[s("li",[a._v("线程 1 把本地内存中修改过的共享变量副本的值同步到主内存中去。")]),a._v(" "),s("li",[a._v("线程 2 到主存中读取对应的共享变量的值。")])]),a._v(" "),s("p",[a._v("也就是说，JMM 为共享变量提供了可见性的保障。")]),a._v(" "),s("p",[a._v("不过，多线程下，对主内存中的一个共享变量进行操作有可能诱发线程安全问题。举个例子：")]),a._v(" "),s("ol",[s("li",[a._v("线程 1 和线程 2 分别对同一个共享变量进行操作，一个执行修改，一个执行读取。")]),a._v(" "),s("li",[a._v("线程 2 读取到的是线程 1 修改之前的值还是修改后的值并不确定，都有可能，因为线程 1 和线程 2 都是先将共享变量从主内存拷贝到对应线程的工作内存中。")])]),a._v(" "),s("p",[a._v("关于主内存与工作内存直接的具体交互协议，即一个变量如何从主内存拷贝到工作内存，如何从工作内存同步到主内存之间的实现细节，Java 内存模型定义来以下八种同步操作（了解即可，无需死记硬背）：")]),a._v(" "),s("ul",[s("li",[s("strong",[a._v("锁定（lock）")]),a._v(": 作用于主内存中的变量，将他标记为一个线程独享变量。")]),a._v(" "),s("li",[s("strong",[a._v("解锁（unlock）")]),a._v(": 作用于主内存中的变量，解除变量的锁定状态，被解除锁定状态的变量才能被其他线程锁定。")]),a._v(" "),s("li",[s("strong",[a._v("read（读取）")]),a._v("：作用于主内存的变量，它把一个变量的值从主内存传输到线程的工作内存中，以便随后的 load 动作使用。")]),a._v(" "),s("li",[s("strong",[a._v("load(载入)")]),a._v("：把 read 操作从主内存中得到的变量值放入工作内存的变量的副本中。")]),a._v(" "),s("li",[s("strong",[a._v("use(使用)")]),a._v("：把工作内存中的一个变量的值传给执行引擎，每当虚拟机遇到一个使用到变量的指令时都会使用该指令。")]),a._v(" "),s("li",[s("strong",[a._v("assign（赋值）")]),a._v("：作用于工作内存的变量，它把一个从执行引擎接收到的值赋给工作内存的变量，每当虚拟机遇到一个给变量赋值的字节码指令时执行这个操作。")]),a._v(" "),s("li",[s("strong",[a._v("store（存储）")]),a._v("：作用于工作内存的变量，它把工作内存中一个变量的值传送到主内存中，以便随后的 write 操作使用。")]),a._v(" "),s("li",[s("strong",[a._v("write（写入）")]),a._v("：作用于主内存的变量，它把 store 操作从工作内存中得到的变量的值放入主内存的变量中。")])]),a._v(" "),s("p",[a._v("除了这 8 种同步操作之外，还规定了下面这些同步规则来保证这些同步操作的正确执行（了解即可，无需死记硬背）：")]),a._v(" "),s("ul",[s("li",[a._v("不允许一个线程无原因地（没有发生过任何 assign 操作）把数据从线程的工作内存同步回主内存中。")]),a._v(" "),s("li",[a._v("一个新的变量只能在主内存中 “诞生”，不允许在工作内存中直接使用一个未被初始化（load 或 assign）的变量，换句话说就是对一个变量实施 use 和 store 操作之前，必须先执行过了 assign 和 load 操作。")]),a._v(" "),s("li",[a._v("一个变量在同一个时刻只允许一条线程对其进行 lock 操作，但 lock 操作可以被同一条线程重复执行多次，多次执行 lock 后，只有执行相同次数的 unlock 操作，变量才会被解锁。")]),a._v(" "),s("li",[a._v("如果对一个变量执行 lock 操作，将会清空工作内存中此变量的值，在执行引擎使用这个变量前，需要重新执行 load 或 assign 操作初始化变量的值。")]),a._v(" "),s("li",[a._v("如果一个变量事先没有被 lock 操作锁定，则不允许对它执行 unlock 操作，也不允许去 unlock 一个被其他线程锁定住的变量")])]),a._v(" "),s("h4",{attrs:{id:"java-内存区域和-jmm-有何区别"}},[s("a",{staticClass:"header-anchor",attrs:{href:"#java-内存区域和-jmm-有何区别"}},[a._v("#")]),a._v(" Java 内存区域和 JMM 有何区别？")]),a._v(" "),s("p",[s("strong",[a._v("Java 内存区域和内存模型是完全不一样的两个东西")]),a._v(" ：")]),a._v(" "),s("ul",[s("li",[a._v("JVM 内存结构和 Java 虚拟机的运行时区域相关，定义了 JVM 在运行时如何分区存储程序数据，就比如说堆主要用于存放对象实例。")]),a._v(" "),s("li",[a._v("Java 内存模型和 Java 的并发编程相关，抽象了线程和主内存之间的关系就比如说线程之间的共享变量必须存储在主内存中，规定了从 Java 源代码到 CPU 可执行指令的这个转化过程要遵守哪些和并发相关的原则和规范，其主要目的是为了简化多线程编程，增强程序可移植性的。")])])])}),[],!1,null,null,null);s.default=e.exports}}]);