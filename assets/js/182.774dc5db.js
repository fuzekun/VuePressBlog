(window.webpackJsonp=window.webpackJsonp||[]).push([[182],{642:function(v,_,p){"use strict";p.r(_);var t=p(1),s=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h3",{attrs:{id:"内存的分配方式"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#内存的分配方式"}},[v._v("#")]),v._v(" 内存的分配方式?")]),v._v(" "),_("p",[v._v("1、连续分配方式")]),v._v(" "),_("p",[v._v("1）固定分区分配：会产生大量的内部碎片；")]),v._v(" "),_("p",[v._v("2）动态分区分配：会产生很多外部碎片；")]),v._v(" "),_("p",[v._v("连续分配的方式因为要求每个进程占用的内存都是连续的，所以会出现很多内存空间的浪费；")]),v._v(" "),_("p",[v._v("2、非连续分配方式")]),v._v(" "),_("p",[v._v("1）基本分页存储管理")]),v._v(" "),_("p",[v._v("思想：把内存分为一个个大小相等的小分区，再按照分区大小把进程拆分成一个个小部分；")]),v._v(" "),_("p",[v._v("内存中的分区：页框、内存块、物理块，对应的页框号，是从0开始的；")]),v._v(" "),_("p",[v._v("用户进程的地址空间也分为与页框大小相等的一个个区域，称为“页”或是“页面”。每个页面有一个自己的编号，即页号，也是从“0”开始的，（进程的最后一个页面可能没有一个页框那么大，所以会产生内部碎片）；")]),v._v(" "),_("p",[v._v("地址转换：逻辑地址---物理地址")]),v._v(" "),_("p",[v._v("连续内存分配管理的地址转换：使用的是动态重定位的方式，首先寄存器保存当前进程在内存中的起始物理地址（偏移量），由于是连续的分配，所以往后的物理地址 = 寄存器中存储的起始地址 + 逻辑地址")]),v._v(" "),_("p",[v._v("分页内存管理中的地址转换：")]),v._v(" "),_("p",[v._v("1、算出逻辑地址对应的页号；")]),v._v(" "),_("p",[v._v("2、要知道该页号对应页面在内存中的起始地址；")]),v._v(" "),_("p",[v._v("3、要算出逻辑地址在页面内的“偏移量”")]),v._v(" "),_("p",[v._v("4、物理地址 = 页面始址 + 页内偏移量")]),v._v(" "),_("p",[v._v("页号 = 逻辑地址 / 页面长度       =  80 / 50 = 1")]),v._v(" "),_("p",[v._v("页内偏移量 = 逻辑地址长度 % 页面长度   =  80  %  50 = 30")]),v._v(" "),_("p",[v._v("每个页在内存中的起始位置由页表给出。")]),v._v(" "),_("p",[v._v("页表寄存器：存放页表在内存中的起始地址F和页表长度M。")]),v._v(" "),_("p",[v._v("2）基本分段存储管理")]),v._v(" "),_("p",[v._v("按照进程的逻辑关系进行分段")]),v._v(" "),_("p",[v._v("会产生外部碎片，但是不会产生内部碎片")]),v._v(" "),_("p",[v._v("段号的长度决定了一个进程可以最多被分为多少段")]),v._v(" "),_("p",[v._v("段内地址的长度决定了一个段的最大长度")]),v._v(" "),_("p",[v._v("段表：段号+段长+基址")]),v._v(" "),_("p",[_("strong",[v._v("内存管理有哪几种方式？")])]),v._v(" "),_("p",[v._v("1）块式管理：内存的利用率很低；")]),v._v(" "),_("p",[v._v("2）页式管理：内存的利用率增高，页式管理不会产生外部碎片，但是会产生内部碎片；")]),v._v(" "),_("p",[v._v("3）段式管理：不会产生内部碎片，但是换入换出时可能会产生外部碎片；")]),v._v(" "),_("p",[v._v("4）段页式管理：将程序分为若干段，将每段分为若干页，段页式存储管理每取一次数据，需要访问3次内存。")])])}),[],!1,null,null,null);_.default=s.exports}}]);